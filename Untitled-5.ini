/var/www/www-root/data/site/vdestor.ru/public/index.php
<?php
declare(strict_types=1);

// Критическая обработка ошибок
error_reporting(E_ALL);
ini_set('display_errors', '0');
ini_set('log_errors', '1');

// Загружаем autoloader
require_once __DIR__ . '/../vendor/autoload.php';

// Минимальная инициализация
try {
    // 1. Config
    \App\Core\Config::get('app.name');

    // 2. Cache (опционально)
    if (class_exists('\App\Core\Cache')) {
        \App\Core\Cache::init();
    }

    // 3. Security headers
    if (class_exists('\App\Core\SecurityManager')) {
        \App\Core\SecurityManager::initialize();
    }

    // 4. Session
    \App\Core\Session::start();

    // 5. Database
    \App\Core\Database::getConnection();

    // 6. Logger (после БД)
    if (class_exists('\App\Core\Logger')) {
        \App\Core\Logger::initialize();
    }

} catch (\Exception $e) {
    error_log("Critical init error: " . $e->getMessage() . " in " . $e->getFile() . ":" . $e->getLine());
    http_response_code(500);
    die('System temporarily unavailable');
}

// Импорты контроллеров
use App\Core\Router;
use App\Controllers\LoginController;
use App\Controllers\AdminController;
use App\Controllers\CartController;
use App\Controllers\SpecificationController;
use App\Controllers\ProductController;
use App\Controllers\ApiController;

// Роутер
$router = new Router();

// API роуты
$apiController = new ApiController();
$router->get('/api/test', [$apiController, 'testAction']);
$router->get('/api/availability', [$apiController, 'availabilityAction']);
$router->get('/api/search', [$apiController, 'searchAction']);
$router->get('/api/autocomplete', [$apiController, 'autocompleteAction']);
$router->get('/api/product/{id}/info', [$productController, 'ajaxProductInfoAction']);

// Авторизация
$loginController = new LoginController();
$router->match(['GET', 'POST'], '/login', [$loginController, 'loginAction']);

$router->get('/logout', function() {
    \App\Services\AuthService::destroySession();
    header('Location: /login');
    exit;
});

// Админ
$adminController = new AdminController();
$router->get('/admin', function() use ($adminController) {
    if (class_exists('\App\Middleware\AuthMiddleware')) {
        \App\Middleware\AuthMiddleware::requireRole('admin');
    }
    $adminController->indexAction();
});

// Корзина
$cartController = new CartController();
$router->match(['GET', 'POST'], '/cart/add', [$cartController, 'addAction']);
$router->get('/cart', [$cartController, 'viewAction']);
$router->post('/cart/clear', [$cartController, 'clearAction']);
$router->post('/cart/remove', [$cartController, 'removeAction']);
$router->get('/cart/json', [$cartController, 'getJsonAction']);

// Спецификации
$specController = new SpecificationController();
$router->match(['GET', 'POST'], '/specification/create', [$specController, 'createAction']);
$router->get('/specification/{id}', [$specController, 'viewAction']);
$router->get('/specifications', [$specController, 'listAction']);

// Товары
$productController = new ProductController();
$router->get('/shop/product', [$productController, 'viewAction']);
$router->get('/shop/product/{id}', [$productController, 'viewByIdAction']);
$router->get('/shop', function() {
    \App\Core\Layout::render('shop/index', []);
});

// Главная
$router->get('/', function() {
    \App\Core\Layout::render('home/index', []);
});

// 404
$router->set404(function() {
    http_response_code(404);
    \App\Core\Layout::render('errors/404', []);
});

// Обработка запроса
try {
    $router->dispatch();
} catch (\Exception $e) {
    error_log("Router error: " . $e->getMessage());

    if (strpos($_SERVER['REQUEST_URI'] ?? '', '/api/') !== false) {
        http_response_code(500);
        header('Content-Type: application/json');
        echo json_encode(['success' => false, 'error' => 'Internal server error']);
    } else {
        http_response_code(500);
        echo "Internal server error";
    }
}
/var/www/www-root/data/site/vdestor.ru/public/header.php
<?php
declare(strict_types=1);
use App\Core\Database;
use App\Core\CSRF;
use App\Services\AuthService;

// ===============================================
// ВАЖНО: CSP уже установлен в nginx конфигурации
// Здесь НЕ переопределяем заголовки безопасности!
// ===============================================

// Дополнительные заголовки только если они не установлены nginx
if (!headers_sent()) {
    // Отключаем кеширование для разработки
    header("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
    header("Pragma: no-cache");
    header("Expires: Sat, 26 Jul 1997 05:00:00 GMT");

    // Эти заголовки НЕ конфликтуют с nginx
    header("Vary: Accept-Encoding");

    // Дополнительные заголовки безопасности
    header("X-Content-Type-Options: nosniff");
    header("X-Frame-Options: SAMEORIGIN");
    header("X-XSS-Protection: 1; mode=block");
    header("Referrer-Policy: strict-origin-when-cross-origin");
}

try {
    $pdo = Database::getConnection();
    $stmt = $pdo->query("SELECT city_id, name FROM cities ORDER BY name");
    $cities = $stmt->fetchAll();
} catch (PDOException $e) {
    error_log('Database error in header.php: ' . $e->getMessage());
    $cities = [];
}

// Получаем текущий путь для активного пункта меню
$current_path = $_SERVER['REQUEST_URI'] ?? '/';
?>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VDestor B2B - Электротехническое оборудование</title>

    <!-- Preconnect для ускорения загрузки -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">

    <!-- Шрифты -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Иконки Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- Фавикон -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">

    <!-- jQuery для совместимости -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- Динамическое подключение CSS от Vite -->
    <?php
    $distPath = $_SERVER['DOCUMENT_ROOT'] . '/assets/dist/assets/';
    if (is_dir($distPath)) {
        $cssFiles = glob($distPath . 'main-*.css');
        foreach ($cssFiles as $cssFile) {
            $cssUrl = str_replace($_SERVER['DOCUMENT_ROOT'], '', $cssFile);
            echo '<link rel="stylesheet" href="' . htmlspecialchars($cssUrl) . '">' . PHP_EOL;
        }
    } else {
        // Fallback стили если Vite еще не собран
        echo '<style>
            body { font-family: Inter, sans-serif; margin: 0; padding: 20px; }
            .error { background: #fee; padding: 20px; border: 1px solid #fcc; border-radius: 4px; }
        </style>' . PHP_EOL;
    }
    ?>
</head>
<body>
    <div class="app-layout">
        <!-- Боковая панель навигации -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/" class="sidebar-logo">
                    <div class="sidebar-logo-icon">V</div>
                    <span class="sidebar-logo-text">VDestor B2B</span>
                </a>
            </div>

            <nav class="sidebar-nav">
                <!-- Основное меню -->
                <div class="nav-section">
                    <div class="nav-section-title">Основное</div>
                    <ul class="nav-menu">
                        <li class="nav-item">
                            <a href="/" class="nav-link <?= $current_path === '/' ? 'active' : '' ?>">
                                <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                                </svg>
                                <span class="nav-text">Дашборд</span>
                            </a>
                        </li>
                        <li class="nav-item">
                            <a href="/shop" class="nav-link <?= strpos($current_path, '/shop') === 0 ? 'active' : '' ?>">
                                <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z"></path>
                                </svg>
                                <span class="nav-text">Каталог товаров</span>
                            </a>
                        </li>
                        <li class="nav-item">
                            <a href="/cart" class="nav-link <?= $current_path === '/cart' ? 'active' : '' ?>">
                                <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path>
                                </svg>
                                <span class="nav-text">Корзина</span>
                                <span class="nav-badge" id="cartBadge" style="display: none;">0</span>
                            </a>
                        </li>
                        <li class="nav-item">
                            <a href="/specifications" class="nav-link <?= strpos($current_path, '/specification') === 0 ? 'active' : '' ?>">
                                <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                                </svg>
                                <span class="nav-text">Спецификации</span>
                            </a>
                        </li>
                    </ul>
                </div>

                <!-- Инструменты -->
                <div class="nav-section">
                    <div class="nav-section-title">Инструменты</div>
                    <ul class="nav-menu">
                        <li class="nav-item">
                            <a href="/calculator" class="nav-link">
                                <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                                </svg>
                                <span class="nav-text">Калькуляторы</span>
                            </a>
                        </li>
                        <li class="nav-item">
                            <a href="/history" class="nav-link">
                                <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <span class="nav-text">История заказов</span>
                            </a>
                        </li>
                    </ul>
                </div>

                <?php if (AuthService::check() && AuthService::checkRole('admin')): ?>
                <!-- Управление (для администраторов) -->
                <div class="nav-section">
                    <div class="nav-section-title">Управление</div>
                    <ul class="nav-menu">
                        <li class="nav-item">
                            <a href="/admin" class="nav-link">
                                <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                </svg>
                                <span class="nav-text">Админ панель</span>
                            </a>
                        </li>
                    </ul>
                </div>
                <?php endif; ?>

                <!-- Пользователь -->
                <div class="nav-section mt-auto mb-4">
                    <ul class="nav-menu">
                        <?php if (AuthService::check()): ?>
                            <li class="nav-item">
                                <a href="/profile" class="nav-link">
                                    <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                                    </svg>
                                    <span class="nav-text">Профиль</span>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="/logout" class="nav-link">
                                    <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                                    </svg>
                                    <span class="nav-text">Выйти</span>
                                </a>
                            </li>
                        <?php else: ?>
                            <li class="nav-item">
                                <a href="/login" class="nav-link">
                                    <svg class="nav-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                                    </svg>
                                    <span class="nav-text">Войти</span>
                                </a>
                            </li>
                        <?php endif; ?>
                    </ul>
                </div>
            </nav>

            <!-- Кнопка сворачивания -->
            <button class="sidebar-toggle" id="sidebarToggle">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path>
                </svg>
            </button>
        </aside>

        <!-- Основная область -->
        <div class="main-wrapper">
            <!-- Верхняя панель -->
            <header class="top-header">
                <div class="header-content">
                    <!-- Кнопка мобильного меню -->
                    <button class="btn btn-icon d-none" id="mobileMenuBtn">
                        <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>

                    <!-- Поиск -->
                    <div class="search-box">
                        <svg class="search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                        </svg>
                        <input type="text" class="search-input" placeholder="Поиск товаров..." id="globalSearch">
                    </div>

                    <!-- Правая часть -->
                    <div class="d-flex align-center gap-3 ml-auto">
                        <!-- Выбор города -->
                        <select id="citySelect" class="form-select form-control" style="width: 200px;">
                            <?php foreach ($cities as $city): ?>
                                <option value="<?= htmlspecialchars((string)$city['city_id'], ENT_QUOTES) ?>">
                                    <?= htmlspecialchars($city['name'], ENT_QUOTES) ?>
                                </option>
                            <?php endforeach; ?>
                            <?php if (empty($cities)): ?>
                                <option value="3">Ярославль</option>
                            <?php endif; ?>
                        </select>

                        <!-- Уведомления -->
                        <button class="btn btn-icon" id="notificationsBtn">
                            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path>
                            </svg>
                        </button>

                        <!-- Быстрая корзина -->
                        <button class="btn btn-primary btn-sm" onclick="window.location.href='/cart'">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path>
                            </svg>
                            <span>Корзина</span>
                        </button>
                    </div>
                </div>
            </header>

            <!-- Основной контент -->
            <main class="main-content">
                <div class="page-container">

<script>
    window.CSRF_TOKEN = <?= json_encode(CSRF::token(), JSON_HEX_TAG) ?>;
    window.USER_LOGGED_IN = <?= AuthService::check() ? 'true' : 'false' ?>;

    // Простая замена для ColResizable функциональности
    window.initTableResize = function() {
        console.log('Table resize functionality loaded');
        // Здесь можно добавить свою реализацию изменения размера колонок
        // или просто оставить пустой функцией если функция не критична
    };

    // Восстановление состояния сайдбара
    document.addEventListener('DOMContentLoaded', function() {
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');

        // Проверка сохраненного состояния
        const sidebarCollapsed = localStorage.getItem('sidebar-collapsed') === 'true';
        if (sidebarCollapsed) {
            sidebar.classList.add('collapsed');
        }

        // Переключение сайдбара
        sidebarToggle.addEventListener('click', function() {
            sidebar.classList.toggle('collapsed');
            localStorage.setItem('sidebar-collapsed', sidebar.classList.contains('collapsed'));
        });

        // Мобильное меню
        if (window.innerWidth <= 768) {
            mobileMenuBtn.classList.remove('d-none');
            mobileMenuBtn.addEventListener('click', function() {
                sidebar.classList.toggle('mobile-open');
            });
        }

        // Обновление количества в корзине
        updateCartBadge();

        // Инициализация таблиц
        if (typeof window.initTableResize === 'function') {
            window.initTableResize();
        }
    });

    // Функция обновления бейджа корзины
    function updateCartBadge() {
        fetch('/cart/json')
            .then(res => res.json())
            .then(data => {
                const cartBadge = document.getElementById('cartBadge');
                const cart = data.cart || {};
                const totalItems = Object.values(cart).reduce((sum, item) => sum + (item.quantity || 0), 0);

                if (totalItems > 0) {
                    cartBadge.textContent = totalItems;
                    cartBadge.style.display = 'block';
                } else {
                    cartBadge.style.display = 'none';
                }
            })
            .catch(() => {
                // Игнорируем ошибки
            });
    }
</script>

/var/www/www-root/data/site/vdestor.ru/public/footer.php
</div> <!-- .page-container -->
            </main> <!-- .main-content -->
        </div> <!-- .main-wrapper -->
    </div> <!-- .app-layout -->

    <!-- Toast контейнер для уведомлений -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Основной JavaScript -->
    <script>
        // CSRF токен для всех AJAX запросов
        window.CSRF_TOKEN = <?= json_encode(\App\Core\CSRF::token(), JSON_HEX_TAG) ?>;

        // Функция показа уведомлений
        function showToast(message, type = 'info', duration = 3000) {
            const toastContainer = document.getElementById('toastContainer');

            const toast = document.createElement('div');
            toast.className = `toast toast-${type} show`;

            const icons = {
                success: '<svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>',
                error: '<svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>',
                warning: '<svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>',
                info: '<svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>'
            };

            toast.innerHTML = `
                <div class="toast-icon">${icons[type] || icons.info}</div>
                <div class="toast-content">
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">
                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                    </svg>
                </button>
            `;

            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, duration);
        }

        // Глобальный поиск
        const globalSearch = document.getElementById('globalSearch');
        if (globalSearch) {
            let searchTimeout;

            globalSearch.addEventListener('input', function(e) {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();

                if (query.length > 2) {
                    searchTimeout = setTimeout(() => {
                        // Здесь должен быть AJAX поиск
                        console.log('Поиск:', query);
                    }, 500);
                }
            });
        }

        // Обработка выбора города
        const citySelect = document.getElementById('citySelect');
        if (citySelect) {
            citySelect.addEventListener('change', function(e) {
                const cityId = e.target.value;
                const cityName = e.target.options[e.target.selectedIndex].text;

                // Сохраняем в localStorage
                localStorage.setItem('selected_city_id', cityId);
                localStorage.setItem('selected_city_name', cityName);

                // Обновляем страницу или делаем AJAX запрос
                showToast(`Город изменен на ${cityName}`, 'success');

                // Обновляем данные о наличии товаров
                if (typeof window.updateCityAvailability === 'function') {
                    window.updateCityAvailability(cityId);
                }
            });
        }

        // Восстановление выбранного города
        document.addEventListener('DOMContentLoaded', function() {
            const savedCityId = localStorage.getItem('selected_city_id');
            if (savedCityId && citySelect) {
                citySelect.value = savedCityId;
            }
        });

        // Функция для добавления товара в корзину (глобальная)
        window.addToCart = function(productId, quantity = 1) {
            fetch('/cart/add', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    productId: productId,
                    quantity: quantity,
                    csrf_token: window.CSRF_TOKEN
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Товар добавлен в корзину', 'success');
                    updateCartBadge();
                } else {
                    showToast(data.message || 'Ошибка добавления', 'error');
                }
            })
            .catch(error => {
                showToast('Ошибка сервера', 'error');
            });
        };

        // Функция обновления бейджа корзины
        function updateCartBadge() {
            fetch('/cart/json')
                .then(res => res.json())
                .then(data => {
                    const cartBadge = document.getElementById('cartBadge');
                    if (cartBadge) {
                        const cart = data.cart || {};
                        const totalItems = Object.values(cart).reduce((sum, item) => sum + (item.quantity || 0), 0);

                        if (totalItems > 0) {
                            cartBadge.textContent = totalItems;
                            cartBadge.style.display = 'block';
                        } else {
                            cartBadge.style.display = 'none';
                        }
                    }
                })
                .catch(() => {
                    // Игнорируем ошибки
                });
        }

        // Функция загрузки наличия товаров
        window.loadAvailability = function(productIds) {
            const cityId = document.getElementById('citySelect')?.value || '1';

            fetch('/api/availability', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    product_ids: productIds,
                    city_id: cityId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.data) {
                    Object.entries(data.data).forEach(([productId, info]) => {
                        updateProductAvailability(productId, info);
                    });
                }
            })
            .catch(error => {
                console.error('Ошибка загрузки наличия:', error);
            });
        };

        // Обновление информации о наличии товара
        function updateProductAvailability(productId, data) {
            const row = document.querySelector(`tr[data-product-id="${productId}"]`);
            if (!row) return;

            const availCell = row.querySelector('.availability-cell');
            const deliveryCell = row.querySelector('.delivery-date-cell');

            if (availCell) {
                const qty = data.quantity || 0;
                availCell.textContent = qty > 0 ? `${qty} шт` : 'Нет в наличии';
                availCell.className = 'availability-cell ' + (qty > 10 ? 'text-success' : qty > 0 ? 'text-warning' : 'text-danger');
            }

            if (deliveryCell && data.delivery_date) {
                deliveryCell.textContent = new Date(data.delivery_date).toLocaleDateString('ru-RU');
            }
        }

        // Анимация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            // Обновляем счетчик корзины
            updateCartBadge();

            // Анимация карточек
            const animateElements = document.querySelectorAll('.stat-card, .card, .table-wrapper');
            animateElements.forEach((el, index) => {
                el.style.opacity = '0';
                el.style.transform = 'translateY(20px)';

                setTimeout(() => {
                    el.style.transition = 'all 0.5s ease-out';
                    el.style.opacity = '1';
                    el.style.transform = 'translateY(0)';
                }, index * 100);
            });
        });
    </script>

    <!-- Подключаем скомпилированные Vite файлы -->
    <?php
    // Динамическое подключение файлов после сборки
    $distPath = $_SERVER['DOCUMENT_ROOT'] . '/assets/dist/assets/';

    if (is_dir($distPath)) {
        // Ищем CSS файлы
        $cssFiles = glob($distPath . 'main-*.css');
        foreach ($cssFiles as $cssFile) {
            $cssUrl = str_replace($_SERVER['DOCUMENT_ROOT'], '', $cssFile);
            echo '<link rel="stylesheet" href="' . htmlspecialchars($cssUrl) . '">' . PHP_EOL;
        }

        // Ищем JS файлы
        $jsFiles = glob($distPath . 'main-*.js');
        foreach ($jsFiles as $jsFile) {
            $jsUrl = str_replace($_SERVER['DOCUMENT_ROOT'], '', $jsFile);
            echo '<script type="module" src="' . htmlspecialchars($jsUrl) . '"></script>' . PHP_EOL;
        }
    } else {
        // Fallback если файлы еще не собраны
        echo '<!-- Vite assets not found. Run "npm run build" to generate them. -->' . PHP_EOL;
    }
    ?>
</body>
</html>

/var/www/www-root/data/site/vdestor.ru/src/js/ProductsManager.js
/**
 * Унифицированный менеджер товаров
 * Заменяет ProductManager.js и дублирующий функционал
 */

import { showToast } from './utils.js';

// ===== API Сервис =====
class ProductAPIService {
    constructor() {
        this.baseUrl = '/api';
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5 минут
    }

    async search(params) {
        const url = new URL(`${this.baseUrl}/search`, window.location.origin);
        Object.entries(params).forEach(([key, value]) => {
            if (value !== null && value !== undefined && value !== '') {
                url.searchParams.append(key, value);
            }
        });

        try {
            const response = await fetch(url, {
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });

            console.log('🌐 [ProductAPIService] Response status:', response.status);
            console.log('🌐 [ProductAPIService] Response ok:', response.ok);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const responseText = await response.text();
            console.log('📄 [ProductAPIService] Raw response:', responseText.substring(0, 500) + '...');

            let result;
            try {
                result = JSON.parse(responseText);
            } catch (parseError) {
                console.error('❌ [ProductAPIService] JSON parse error:', parseError);
                console.error('❌ [ProductAPIService] Response text:', responseText);
                throw new Error('Invalid JSON response');
            }

            console.log('📦 [ProductAPIService] Parsed result:', result);
            return result;

        } catch (error) {
            console.error('💥 [ProductAPIService] Search error:', error);
            return {
                success: false,
                error: error.message,
                data: { products: [], total: 0 }
            };
        }
    }

    async getAvailability(productIds, cityId) {
        const url = new URL(`${this.baseUrl}/availability`, window.location.origin);
        url.searchParams.append('city_id', cityId);
        url.searchParams.append('product_ids', productIds.join(','));

        try {
            const response = await fetch(url);
            const result = await response.json();

            if (result.success) {
                return result.data || {};
            }
            return {};
        } catch (error) {
            console.error('Availability error:', error);
            return {};
        }
    }

    getCSRFToken() {
        return window.CSRF_TOKEN || '';
    }
}

// ===== Главный менеджер =====
export class ProductsManager {
    constructor() {
        this.api = new ProductAPIService();

        // Состояние совместимое со старым кодом
        this.products = [];
        this.currentPage = parseInt(sessionStorage.getItem('currentPage') || '1');
        this.itemsPerPage = parseInt(sessionStorage.getItem('itemsPerPage') || '20');
        this.totalProducts = 0;
        this.sortColumn = sessionStorage.getItem('sortColumn') || 'name';
        this.sortDirection = sessionStorage.getItem('sortDirection') || 'asc';
        this.appliedFilters = {};
        this.isLoading = false;

        // Восстанавливаем фильтры
        Object.keys(sessionStorage).forEach(key => {
            if (!['itemsPerPage', 'sortColumn', 'sortDirection', 'currentPage'].includes(key)) {
                this.appliedFilters[key] = sessionStorage.getItem(key);
            }
        });

        // Определяем режим
        this.isTableView = !!document.querySelector('.product-table');
        this.isShopView = !!document.querySelector('.shop-container');

        this.init();
    }

    init() {
        this.bindEvents();

        // Устанавливаем глобальные переменные для совместимости
        window.productsData = this.products;
        window.currentPage = this.currentPage;
        window.itemsPerPage = this.itemsPerPage;
        window.totalProducts = this.totalProducts;
        window.sortColumn = this.sortColumn;
        window.sortDirection = this.sortDirection;
        window.appliedFilters = this.appliedFilters;
    }

    bindEvents() {
        // Поиск
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const value = e.target.value.trim();

                if (value) {
                    this.appliedFilters.search = value;
                    sessionStorage.setItem('search', value);
                } else {
                    delete this.appliedFilters.search;
                    sessionStorage.removeItem('search');
                }

                searchTimeout = setTimeout(() => {
                    this.currentPage = 1;
                    this.fetchProducts();
                }, 300);
            });

            // Восстанавливаем значение
            if (this.appliedFilters.search) {
                searchInput.value = this.appliedFilters.search;
            }
        }
    }

    async fetchProducts() {
        console.log('🔄 [ProductsManager] Starting fetchProducts...');

        if (this.isLoading) {
            console.log('⏳ [ProductsManager] Already loading, skipping...');
            return;
        }

        this.isLoading = true;
        this.showLoadingIndicator();

        try {
            const params = {
                q: this.appliedFilters.search || '',
                page: this.currentPage,
                limit: this.itemsPerPage,
                sort: this.convertSortToApiFormat(this.sortColumn, this.sortDirection),
                city_id: document.getElementById('citySelect')?.value || '1'
            };

            // Добавляем фильтры
            Object.entries(this.appliedFilters).forEach(([key, value]) => {
                if (key !== 'search' && value) {
                    params[key] = value;
                }
            });

            console.log('📤 [ProductsManager] API Request params:', params);

            const result = await this.api.search(params);
            console.log('📦 [ProductsManager] API Response:', result);
            console.log('🔍 [ProductsManager] API Response type:', typeof result);
            console.log('✅ [ProductsManager] API Response success field:', result.success);

            // ИСПРАВЛЕННАЯ ПРОВЕРКА
            const isSuccessful = result.success === true ||
                               (result.data && result.data.products) ||
                               (result.products); // На случай если данные в корне

            console.log('🎯 [ProductsManager] Is successful:', isSuccessful);

            if (isSuccessful) {
                // Пробуем разные структуры ответа
                this.products = result.data?.products || result.products || [];
                this.totalProducts = result.data?.total || result.total || 0;

                console.log('✅ [ProductsManager] Products extracted:', this.products.length);
                console.log('📊 [ProductsManager] Total products:', this.totalProducts);
                console.log('🔍 [ProductsManager] First product sample:', this.products[0]);

                // Обновляем глобальные переменные
                window.productsData = this.products;
                window.totalProducts = this.totalProducts;

                console.log('🌍 [ProductsManager] Global variables updated');
                console.log('🌍 [ProductsManager] window.productsData length:', window.productsData.length);

                // Проверяем наличие функции рендеринга
                if (typeof window.renderProductsTable === 'function') {
                    console.log('🎨 [ProductsManager] Calling renderProductsTable...');
                    window.renderProductsTable();
                    console.log('✅ [ProductsManager] renderProductsTable called');
                } else {
                    console.error('❌ [ProductsManager] renderProductsTable is not a function!', typeof window.renderProductsTable);

                    // Пробуем найти функцию в других местах
                    console.log('🔍 [ProductsManager] Searching for renderProductsTable...');
                    console.log('🔍 [ProductsManager] In window:', Object.keys(window).filter(k => k.includes('render')));
                }

                this.updatePaginationDisplay();

                // Загружаем наличие
                if (this.products.length > 0) {
                    this.loadAvailability();
                }
            } else {
                console.error('❌ [ProductsManager] API returned unsuccessful result');
                console.error('❌ [ProductsManager] Result structure:', Object.keys(result));
                console.error('❌ [ProductsManager] Result.success:', result.success);
                console.error('❌ [ProductsManager] Result.data:', result.data);
                console.error('❌ [ProductsManager] Result.error:', result.error);

                this.products = [];
                this.totalProducts = 0;
                window.productsData = [];
                window.totalProducts = 0;

                if (window.renderProductsTable) {
                    window.renderProductsTable();
                }

                showToast('Ошибка загрузки товаров: ' + (result.error || result.message || 'Неизвестная ошибка'), true);
            }
        } catch (error) {
            console.error('💥 [ProductsManager] Fetch error:', error);
            console.error('💥 [ProductsManager] Error stack:', error.stack);

            this.products = [];
            this.totalProducts = 0;
            window.productsData = [];
            window.totalProducts = 0;

            if (window.renderProductsTable) {
                window.renderProductsTable();
            }

            showToast('Ошибка загрузки: ' + error.message, true);
        } finally {
            this.isLoading = false;
            this.hideLoadingIndicator();
            console.log('🏁 [ProductsManager] fetchProducts completed');
        }
    }

    async loadAvailability() {
        const productIds = this.products.map(p => p.product_id);
        const cityId = document.getElementById('citySelect')?.value || '1';

        const availabilityData = await this.api.getAvailability(productIds, cityId);

        // Обновляем UI через существующую функцию
        if (window.loadAvailability) {
            window.loadAvailability(productIds);
        }
    }

    convertSortToApiFormat(column, direction) {
        if (column === 'base_price' || column === 'price') {
            return direction === 'asc' ? 'price_asc' : 'price_desc';
        }

        const sortableColumns = ['name', 'external_id', 'sku', 'availability', 'popularity'];
        if (sortableColumns.includes(column)) {
            return column;
        }

        return 'relevance';
    }

    updatePaginationDisplay() {
        const totalPages = Math.ceil(this.totalProducts / this.itemsPerPage);

        // Обновляем все элементы пагинации
        document.querySelectorAll('#currentPage, #currentPageBottom').forEach(el => {
            if (el) el.textContent = this.currentPage;
        });

        document.querySelectorAll('#totalPages, #totalPagesBottom').forEach(el => {
            if (el) el.textContent = totalPages;
        });

        document.querySelectorAll('#totalProductsText, #totalProductsTextBottom').forEach(el => {
            if (el) el.textContent = `Найдено товаров: ${this.totalProducts}`;
        });

        // Управление кнопками
        document.querySelectorAll('.prev-btn').forEach(btn => {
            if (btn) btn.disabled = this.currentPage <= 1;
        });

        document.querySelectorAll('.next-btn').forEach(btn => {
            if (btn) btn.disabled = this.currentPage >= totalPages;
        });

        // Обновляем глобальную функцию если она есть
        if (window.updatePaginationDisplay) {
            window.updatePaginationDisplay();
        }
    }

    showLoadingIndicator() {
        const existing = document.querySelector('.loading-indicator');
        if (existing) return;

        const indicator = document.createElement('div');
        indicator.className = 'loading-indicator';
        indicator.innerHTML = `
            <div class="spinner-border spinner-border-sm"></div>
            <span>Загрузка...</span>
        `;
        indicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 9999;
        `;
        document.body.appendChild(indicator);
    }

    hideLoadingIndicator() {
        const indicator = document.querySelector('.loading-indicator');
        if (indicator) {
            indicator.remove();
        }
    }

    // Методы для совместимости
    sortProducts(column) {
        if (this.sortColumn === column) {
            this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            this.sortColumn = column;
            this.sortDirection = 'asc';
        }

        sessionStorage.setItem('sortColumn', this.sortColumn);
        sessionStorage.setItem('sortDirection', this.sortDirection);

        // Обновляем глобальные переменные
        window.sortColumn = this.sortColumn;
        window.sortDirection = this.sortDirection;

        this.currentPage = 1;
        this.fetchProducts();
    }

    loadPage(page) {
        this.currentPage = page;
        window.currentPage = page;
        sessionStorage.setItem('currentPage', page);
        this.fetchProducts();
    }
}

// Экспорт экземпляра для использования
export const productsManager = new ProductsManager();

// Делаем методы доступными глобально для совместимости
window.fetchProducts = () => productsManager.fetchProducts();
window.sortProducts = (column) => productsManager.sortProducts(column);
window.loadPage = (page) => productsManager.loadPage(page);

/var/www/www-root/data/site/vdestor.ru/src/js/utils.js
// /var/www/www-root/data/site/vdestor.ru/src/js/utils.js

// ============================================================================
// ПЕРЕХОДНАЯ ВЕРСИЯ utils.js
// Постепенно мигрируем функции в специализированные сервисы
// ============================================================================

import { productsManager } from './ProductsManager.js';

// ===== TOAST УВЕДОМЛЕНИЯ =====
export function showToast(message, isError = false) {
    const toast = document.createElement('div');
    toast.className = `toast ${isError ? 'toast-error' : 'toast-success'} show`;
    toast.innerHTML = `
        <div class="toast-content">
            <div class="toast-message">${message}</div>
        </div>
    `;

    const container = document.getElementById('toastContainer') || document.body;
    container.appendChild(toast);

    setTimeout(() => toast.remove(), 3000);
}

// ===== ИНДИКАТОРЫ ЗАГРУЗКИ =====
export function showLoadingIndicator() {
    const existing = document.querySelector('.loading-indicator');
    if (existing) return;

    const indicator = document.createElement('div');
    indicator.className = 'loading-indicator';
    indicator.innerHTML = `
        <div class="spinner-border spinner-border-sm"></div>
        <span>Загрузка...</span>
    `;
    indicator.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 9999;
    `;
    document.body.appendChild(indicator);
}

export function hideLoadingIndicator() {
    const indicator = document.querySelector('.loading-indicator');
    if (indicator) {
        indicator.remove();
    }
}

// ===== ЗАГРУЗКА ТОВАРОВ (ПЕРЕХОДНАЯ ВЕРСИЯ) =====
/**
 * @deprecated Используйте productsManager.fetchProducts() вместо этого
 * Эта функция оставлена для обратной совместимости
 */
export async function fetchProducts() {
    console.warn('⚠️ [DEPRECATED] utils.fetchProducts() устарел. Используйте productsManager.fetchProducts()');

    // Переадресуем на новый менеджер
    if (productsManager && typeof productsManager.fetchProducts === 'function') {
        return await productsManager.fetchProducts();
    }

    // Fallback для случаев, когда новый менеджер недоступен
    console.error('❌ ProductsManager недоступен, используем fallback');

    try {
        showLoadingIndicator();

        const params = new URLSearchParams({
            q: window.appliedFilters?.search || '',
            page: window.currentPage || 1,
            limit: window.itemsPerPage || 20,
            city_id: document.getElementById('citySelect')?.value || '1'
        });

        const response = await fetch(`/api/search?${params}`);
        const result = await response.json();

        if (result.success !== false && result.data) {
            window.productsData = result.data.products || [];
            window.totalProducts = result.data.total || 0;

            if (window.renderProductsTable) {
                window.renderProductsTable();
            }
        }

    } catch (error) {
        console.error('Fallback fetch error:', error);
        showToast('Ошибка загрузки товаров', true);
    } finally {
        hideLoadingIndicator();
    }
}

// ===== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ =====
export function getCurrentCityId() {
    return document.getElementById('citySelect')?.value || '1';
}

export function formatPrice(price) {
    if (!price) return '—';
    return `${parseFloat(price).toFixed(2)} ₽`;
}

export function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ===== МИГРАЦИОННЫЕ ЗАМЕТКИ =====
/**
 * ПЛАН МИГРАЦИИ:
 *
 * 1. ✅ showToast - оставляем в utils (используется везде)
 * 2. ✅ showLoadingIndicator/hideLoadingIndicator - оставляем в utils
 * 3. ⚠️ fetchProducts - помечен как deprecated, переадресует на ProductsManager
 * 4. 🔄 Постепенно заменяем вызовы utils.fetchProducts() на productsManager.fetchProducts()
 *
 * В будущем utils.js будет содержать только общие утилиты,
 * а бизнес-логика переедет в специализированные сервисы.
 */

 /var/www/www-root/data/site/vdestor.ru/src/js/renderProducts.js
 import { filterByBrandOrSeries, renderAppliedFilters, highlightFilteredWords } from "./filters.js";
import { loadAvailability } from "./availability.js";
import { showToast } from "./utils.js";

export function copyText(text) {
    if (!text) {
        showToast('Нечего копировать', true);
        return;
    }
    if (!navigator.clipboard) {
        showToast('Clipboard API не поддерживается', true);
        return;
    }
    navigator.clipboard.writeText(text)
        .then(() => showToast(`Скопировано: ${text}`))
        .catch(() => showToast('Не удалось скопировать', true));
}

export function bindSortableHeaders() {
    const table = document.querySelector('.product-table');
    if (!table) return;
    table.removeEventListener('click', sortableClickHandler);
    table.addEventListener('click', sortableClickHandler);
}

function sortableClickHandler(e) {
    const th = e.target.closest('th.sortable');
    if (th && window.sortProducts) window.sortProducts(th.dataset.column);
}

export function renderProductsTable() {
    console.log('🎨 renderProductsTable called, products:', window.productsData); // ОТЛАДКА

    const tbody = document.querySelector('.product-table tbody');
    if (!tbody) {
        console.error('❌ Table tbody not found!'); // ОТЛАДКА
        return;
    }

    tbody.innerHTML = '';

    if (!window.productsData || window.productsData.length === 0) {
        console.warn('⚠️ No products to render'); // ОТЛАДКА
        tbody.innerHTML = '<tr><td colspan="13" class="text-center">Товары не найдены</td></tr>';
        return;
    }

    const fragment = document.createDocumentFragment();
    window.productsData.forEach(product => {
        fragment.appendChild(createProductRow(product));
    });
    tbody.appendChild(fragment);

    updateUI();
    loadMissingAvailability();
    initializeColResizable();
}

function createProductRow(product) {
    const row = document.createElement('tr');
    row.setAttribute('data-product-id', product.product_id);

    row.appendChild(createSelectCell(product));
    row.appendChild(createCodeCell(product));
    row.appendChild(createImageCell(product));
    row.appendChild(createNameCell(product));
    row.appendChild(createSkuCell(product));
    row.appendChild(createBrandSeriesCell(product));
    row.appendChild(createStatusCell(product));
    row.appendChild(createMinSaleUnitCell(product));
    row.appendChild(createAvailabilityCell(product));
    row.appendChild(createDeliveryDateCell(product));
    row.appendChild(createPriceCell(product));
    row.appendChild(createRetailPriceCell(product));
    row.appendChild(createCartCell(product));
    row.appendChild(createAdditionalFieldsCell());
    row.appendChild(createOrdersCountCell(product));

    return row;
}

function createSelectCell(product) {
    const cell = document.createElement('td');
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.classList.add('product-checkbox');
    cell.appendChild(checkbox);
    return cell;
}

function createCodeCell(product) {
    const cell = document.createElement('td');
    cell.classList.add('col-code');
    const codeItem = document.createElement('div');
    codeItem.className = 'item-code';
    const codeSpan = document.createElement('span');
    codeSpan.textContent = product.external_id || '';
    codeItem.appendChild(codeSpan);
    const copyIcon = createCopyIcon(product.external_id);
    codeItem.appendChild(copyIcon);
    cell.appendChild(codeItem);
    return cell;
}

function createImageCell(product) {
    const cell = document.createElement('td');
    const urls = getProductImages(product);
    const firstUrl = urls[0] || '/images/placeholder.jpg';
    const container = document.createElement('div');
    container.className = 'image-container';
    container.style.position = 'relative';
    const thumb = document.createElement('img');
    thumb.src = firstUrl;
    thumb.alt = product.name || '';
    thumb.style.width = '50px';
    thumb.style.cursor = 'pointer';
    thumb.style.transition = 'opacity 0.3s ease';
    const zoom = document.createElement('img');
    zoom.className = 'zoom-image';
    zoom.src = firstUrl;
    zoom.alt = product.name || '';
    zoom.style.width = '350px';
    zoom.style.position = 'absolute';
    zoom.style.top = '0';
    zoom.style.left = '60px';
    zoom.style.opacity = '0';
    zoom.style.transition = 'opacity 0.3s ease';
    zoom.style.pointerEvents = 'none';
    zoom.style.zIndex = '1000';
    zoom.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
    zoom.style.backgroundColor = 'white';
    zoom.style.padding = '5px';
    zoom.style.border = '1px solid #ddd';
    zoom.style.borderRadius = '4px';

    thumb.addEventListener('mouseenter', () => {
        zoom.style.opacity = '1';
        zoom.style.pointerEvents = 'auto';
    });
    thumb.addEventListener('mouseleave', () => {
        zoom.style.opacity = '0';
        zoom.style.pointerEvents = 'none';
    });
    container.appendChild(thumb);
    container.appendChild(zoom);
    const link = document.createElement('a');
    link.href = `/shop/product?id=${product.external_id}`;
    link.appendChild(container);
    cell.appendChild(link);
    return cell;
}

function createNameCell(product) {
    const cell = document.createElement('td');
    cell.className = 'name-cell';
    const link = document.createElement('a');
    link.href = `/shop/product?id=${product.external_id}`;
    link.style.color = 'inherit';
    link.style.textDecoration = 'none';
    const nameItem = document.createElement('div');
    nameItem.className = 'item-code';
    const nameSpan = document.createElement('span');

    if (product._highlight && product._highlight.name) {
        nameSpan.innerHTML = product._highlight.name[0];
    } else {
        nameSpan.textContent = product.name || '';
    }

    nameItem.appendChild(nameSpan);
    const copyIcon = createCopyIcon(product.name);
    nameItem.appendChild(copyIcon);
    link.appendChild(nameItem);
    cell.appendChild(link);
    return cell;
}

function createSkuCell(product) {
    const cell = document.createElement('td');
    const skuItem = document.createElement('div');
    skuItem.className = 'item-code';
    const skuSpan = document.createElement('span');
    skuSpan.textContent = product.sku || '';
    skuItem.appendChild(skuSpan);
    const copyIcon = createCopyIcon(product.sku);
    skuItem.appendChild(copyIcon);
    cell.appendChild(skuItem);
    return cell;
}

function createBrandSeriesCell(product) {
    const cell = document.createElement('td');
    const div = document.createElement('div');
    const brandSpan = document.createElement('span');
    brandSpan.className = 'brand-name';
    brandSpan.textContent = product.brand_name || '';
    brandSpan.style.cursor = 'pointer';
    brandSpan.addEventListener('click', () => filterByBrandOrSeries('brand_name', product.brand_name));
    const seriesSpan = document.createElement('span');
    seriesSpan.className = 'series-name';
    seriesSpan.textContent = product.series_name || '';
    seriesSpan.style.cursor = 'pointer';
    seriesSpan.addEventListener('click', () => filterByBrandOrSeries('series_name', product.series_name));
    if (brandSpan.textContent && seriesSpan.textContent) {
        brandSpan.textContent += ' / ';
    }
    div.appendChild(brandSpan);
    div.appendChild(seriesSpan);
    cell.appendChild(div);
    return cell;
}

function createStatusCell(product) {
    const cell = document.createElement('td');
    const span = document.createElement('span');
    span.textContent = product.status || 'Активен';
    cell.appendChild(span);
    return cell;
}

function createMinSaleUnitCell(product) {
    const cell = document.createElement('td');
    const minSaleSpan = document.createElement('span');
    minSaleSpan.textContent = product.min_sale || '';
    const unitSpan = document.createElement('span');
    unitSpan.textContent = product.unit ? ` / ${product.unit}` : '';
    cell.appendChild(minSaleSpan);
    cell.appendChild(unitSpan);
    return cell;
}

function createAvailabilityCell(product) {
    const cell = document.createElement('td');
    cell.classList.add('col-availability');
    const span = document.createElement('span');
    if (product.stock) {
        const qty = product.stock.quantity || 0;
        span.textContent = qty > 0 ? `${qty} шт.` : "Нет";
        span.classList.toggle('in-stock', qty > 0);
        span.classList.toggle('out-of-stock', qty === 0);
    } else {
        span.textContent = '…';
    }
    cell.appendChild(span);
    return cell;
}

function createDeliveryDateCell(product) {
    const cell = document.createElement('td');
    cell.classList.add('col-delivery-date');
    const span = document.createElement('span');
    if (product.delivery) {
        span.textContent = product.delivery.date || product.delivery.text || '—';
    } else {
        span.textContent = '…';
    }
    cell.appendChild(span);
    return cell;
}

function createPriceCell(product) {
    const cell = document.createElement('td');
    const span = document.createElement('span');
    if (product.price && product.price.final) {
        span.textContent = `${product.price.final.toFixed(2)} руб.`;
        if (product.price.has_special) {
            span.innerHTML = `<span class="price-current">${product.price.final.toFixed(2)} руб.</span>`;
        }
    } else if (product.base_price) {
        span.textContent = `${product.base_price.toFixed(2)} руб.`;
    } else {
        span.textContent = 'Нет цены';
    }
    cell.appendChild(span);
    cell.setAttribute('data-fulltext', span.textContent);
    return cell;
}

function createRetailPriceCell(product) {
    const cell = document.createElement('td');
    const span = document.createElement('span');
    if (product.price && product.price.base && product.price.has_special) {
        span.innerHTML = `<span class="price-old">${product.price.base.toFixed(2)} руб.</span>`;
    } else if (product.retail_price) {
        span.textContent = `${product.retail_price.toFixed(2)} руб.`;
    } else {
        span.textContent = '—';
    }
    cell.appendChild(span);
    cell.setAttribute('data-fulltext', span.textContent);
    return cell;
}

function createCartCell(product) {
    const cell = document.createElement('td');
    const input = document.createElement('input');
    input.className = 'form-control quantity-input';
    input.type = 'number';
    input.value = 1;
    input.min = 1;
    const button = document.createElement('button');
    button.className = 'add-to-cart-btn';
    button.innerHTML = '<i class="fas fa-shopping-cart"></i>';
    button.dataset.productId = product.product_id;
    cell.appendChild(input);
    cell.appendChild(button);
    return cell;
}

function createAdditionalFieldsCell() {
    const cell = document.createElement('td');
    const span = document.createElement('span');
    span.textContent = 'Доп. информация';
    cell.appendChild(span);
    return cell;
}

function createOrdersCountCell(product) {
    const cell = document.createElement('td');
    const span = document.createElement('span');
    span.textContent = product.orders_count || '0';
    cell.appendChild(span);
    return cell;
}

function createCopyIcon(text) {
    const icon = document.createElement('a');
    icon.className = 'copy-icon js-copy-to-clipboard';
    icon.href = '#';
    icon.setAttribute('data-text-to-copy', text || '');
    icon.innerHTML = '<i class="far fa-clone"></i>';
    icon.addEventListener('click', e => {
        e.preventDefault();
        copyText(icon.getAttribute('data-text-to-copy'));
    });
    return icon;
}

function getProductImages(product) {
    let urls = [];
    if (product.images && Array.isArray(product.images)) {
        urls = product.images;
    } else if (typeof product.image_urls === 'string' && product.image_urls.trim()) {
        urls = product.image_urls.split(',').map(u => u.trim());
    }
    return urls;
}

function updateUI() {
    if (typeof window.updatePaginationDisplay === "function") window.updatePaginationDisplay();
    if (typeof window.renderAppliedFilters === "function") window.renderAppliedFilters();
    if (typeof window.highlightFilteredWords === "function") window.highlightFilteredWords();
}

function loadMissingAvailability() {
    const productsNeedingAvailability = window.productsData.filter(p => !p.stock && !p.delivery);
    if (productsNeedingAvailability.length > 0) {
        const ids = productsNeedingAvailability.map(p => p.product_id);
        loadAvailability(ids);
    }
}

function initializeColResizable() {
    try {
        if (typeof jQuery !== 'undefined' && jQuery.fn.colResizable) {
            const $table = jQuery('#productTable');
            if ($table.length > 0) {
                $table.colResizable('destroy');
                $table.colResizable({
                    liveDrag: true,
                    minWidth: 30,
                    hoverCursor: "col-resize"
                });
            }
        }
    } catch (e) {
        console.warn('colResizable не инициализирован:', e.message);
    }
}

/var/www/www-root/data/site/vdestor.ru/src/js/pagination.js
import { renderProductsTable } from "./renderProducts.js";
import { fetchProducts } from "./utils.js";

export function updatePaginationDisplay() {
    const total = Math.ceil(window.totalProducts / window.itemsPerPage);
    document.querySelectorAll('.pagination-info').forEach(el => {
        el.textContent = `Страница ${window.currentPage} из ${total}`;
    });
    document.querySelectorAll('.pageInput').forEach(el => {
        el.value = window.currentPage;
    });
}

export function changeItemsPerPage(event) {
    window.itemsPerPage = parseInt(event.target.value, 10) || 20;
    sessionStorage.setItem('itemsPerPage', window.itemsPerPage);
    window.currentPage = 1;
    fetchProducts();
}

export function changePage(event) {
    let page = parseInt(event.target.value, 10) || 1;
    const total = Math.ceil(window.totalProducts / window.itemsPerPage);
    page = Math.max(1, Math.min(page, total));
    window.currentPage = page;
    fetchProducts();
}

export function handlePageInputKeydown(event) {
    if (event.key === "Enter") {
        changePage(event);
    }
}

export function loadPage(page) {
    window.currentPage = page;
    fetchProducts();
}

/var/www/www-root/data/site/vdestor.ru/src/js/main.js
// /var/www/www-root/data/site/vdestor.ru/src/js/main.js

import "../css/main.css";
import "../css/shop.css";

// ===== ИМПОРТЫ МОДУЛЕЙ =====
import { changeItemsPerPage, changePage, handlePageInputKeydown } from './pagination.js';
import { filterByBrandOrSeries, applyFilters, clearAllFilters } from './filters.js';
import { loadAvailability } from './availability.js';
import { addToCart, clearCart, removeFromCart, fetchCart } from './cart.js';
import { showToast } from './utils.js'; // ✅ Только общие утилиты
import { renderProductsTable, copyText } from './renderProducts.js';
import { createSpecification } from './specification.js';

// ===== ОСНОВНОЙ МЕНЕДЖЕР ТОВАРОВ =====
import { productsManager } from './ProductsManager.js';

// ⚠️ УДАЛЯЕМ этот импорт - он больше не нужен:
// import { fetchProducts } from './utils.js'; // ❌ Убираем!

// ===== ЭКСПОРТ ДЛЯ ОБРАТНОЙ СОВМЕСТИМОСТИ =====
window.renderProductsTable = renderProductsTable;
window.copyText = copyText;
window.createSpecification = createSpecification;
window.loadAvailability = loadAvailability;
window.addToCart = addToCart;
window.clearCart = clearCart;
window.removeFromCart = removeFromCart;
window.fetchCart = fetchCart;
window.filterByBrandOrSeries = filterByBrandOrSeries;
window.applyFilters = applyFilters;
window.clearAllFilters = clearAllFilters;

// ===== НОВАЯ АРХИТЕКТУРА =====
// Экспортируем современные методы
window.productsManager = productsManager;
window.fetchProducts = () => productsManager.fetchProducts(); // ✅ Новая версия
window.sortProducts = (column) => productsManager.sortProducts(column);
window.loadPage = (page) => productsManager.loadPage(page);

// ===== ПОИСК =====
class SearchManager {
    constructor() {
        this.searchInput = null;
        this.globalSearchInput = null;
        this.autocompleteContainer = null;
        this.searchTimeout = null;
        this.selectedIndex = -1;
        this.isSearching = false;
    }

    init() {
        this.searchInput = document.getElementById('searchInput');
        if (this.searchInput) {
            this.setupSearch(this.searchInput);
        }

        this.globalSearchInput = document.getElementById('globalSearch');
        if (this.globalSearchInput) {
            this.setupGlobalSearch(this.globalSearchInput);
        }
    }

    setupSearch(input) {
        // Поиск уже обрабатывается через productsManager
        console.log('✅ Search input managed by ProductsManager');
    }

    setupGlobalSearch(input) {
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && input.value.trim()) {
                window.location.href = `/shop?search=${encodeURIComponent(input.value.trim())}`;
            }
        });
    }
}

const searchManager = new SearchManager();

// ===== ИНИЦИАЛИЗАЦИЯ =====
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 [main.js] DOM loaded, initializing...');

    // Инициализация глобальных переменных
    window.productsData = [];
    window.currentPage = 1;
    window.itemsPerPage = 20;
    window.totalProducts = 0;
    window.sortColumn = 'name';
    window.sortDirection = 'asc';
    window.appliedFilters = {};

    console.log('📋 [main.js] Global variables initialized');

    // Инициализация модулей
    searchManager.init();

    // Город
    const citySelect = document.getElementById('citySelect');
    if (citySelect) {
        citySelect.value = localStorage.getItem('selected_city_id') || '1';
        citySelect.addEventListener('change', () => {
            localStorage.setItem('selected_city_id', citySelect.value);
            // Перезагружаем товары при смене города
            if (window.productsData && window.productsData.length > 0) {
                productsManager.fetchProducts();
            }
        });
    }

    // Количество товаров на странице
    ['itemsPerPageSelect', 'itemsPerPageSelectBottom'].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.value = window.itemsPerPage;
            el.addEventListener('change', changeItemsPerPage);
        }
    });

    // Ввод номера страницы
    ['pageInput', 'pageInputBottom'].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('change', changePage);
            el.addEventListener('keydown', handlePageInputKeydown);
        }
    });

    // Обработчики кликов
    document.body.addEventListener('click', handleBodyClick);

    // Кнопки пагинации
    document.querySelectorAll('.prev-btn').forEach(btn => {
        btn.addEventListener('click', evt => {
            evt.preventDefault();
            productsManager.loadPage(Math.max(1, window.currentPage - 1));
        });
    });

    document.querySelectorAll('.next-btn').forEach(btn => {
        btn.addEventListener('click', evt => {
            evt.preventDefault();
            const totalPages = Math.ceil(window.totalProducts / window.itemsPerPage);
            productsManager.loadPage(Math.min(totalPages, window.currentPage + 1));
        });
    });

    // ===== ЗАГРУЗКА ТОВАРОВ =====
    if (document.querySelector('.product-table')) {
        console.log('📊 [main.js] Product table found, loading products...');

        // Даем небольшую задержку для полной инициализации
        setTimeout(() => {
            productsManager.fetchProducts();
        }, 100);
    } else {
        console.log('ℹ️ [main.js] No product table found on this page');
    }

    // Загрузка корзины
    if (document.querySelector('.cart-container') || document.getElementById('cartBadge')) {
        fetchCart().catch(console.error);
    }
});

// ===== ОБРАБОТЧИК КЛИКОВ =====
function handleBodyClick(e) {
    const target = e.target;

    // Добавить в корзину
    if (target.closest('.add-to-cart-btn')) {
        const btn = target.closest('.add-to-cart-btn');
        const productId = btn.dataset.productId;
        const quantityInput = btn.closest('tr')?.querySelector('.quantity-input');
        const quantity = parseInt(quantityInput?.value || '1', 10);
        addToCart(productId, quantity);
        return;
    }

    // Удалить из корзины
    if (target.closest('.remove-from-cart-btn')) {
        const btn = target.closest('.remove-from-cart-btn');
        removeFromCart(btn.dataset.productId);
        return;
    }

    // Очистить корзину
    if (target.matches('#clearCartBtn')) {
        if (confirm('Очистить корзину?')) {
            clearCart();
        }
        return;
    }

    // Создать спецификацию
    if (target.closest('.create-specification-btn, #createSpecLink')) {
        e.preventDefault();
        createSpecification();
        return;
    }

    // Сортировка
    const sortableHeader = target.closest('th.sortable');
    if (sortableHeader && sortableHeader.dataset.column) {
        productsManager.sortProducts(sortableHeader.dataset.column);
        return;
    }

    // Фильтры по бренду/серии
    if (target.closest('.brand-name, .series-name')) {
        const element = target.closest('.brand-name, .series-name');
        const filterType = element.classList.contains('brand-name') ? 'brand_name' : 'series_name';
        const value = element.textContent.trim();
        filterByBrandOrSeries(filterType, value);
        return;
    }
}

/var/www/www-root/data/site/vdestor.ru/src/js/services/ProductService.js/
/**
 * Централизованный сервис для работы с товарами
 * Версия 2.0 - с интеллектуальным поиском
 */
export class ProductService {
    constructor() {
        this.baseUrl = '/api';
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5 минут
        this.requestTimeout = 10000; // 10 секунд
        this.searchDebounceTime = 300; // мс
        this.searchDebounceTimer = null;
        this.lastSearchQuery = '';
        this.searchHistory = this.loadSearchHistory();
    }

    /**
     * Универсальный поиск товаров с интеллектуальными функциями
     */
    async search(params = {}) {
        const endpoint = `${this.baseUrl}/search`;
        const allowedSorts = ['relevance', 'name', 'price_asc', 'price_desc', 'availability', 'popularity'];

        if (params.sort && !allowedSorts.includes(params.sort)) {
            params.sort = 'relevance';
        }

        // Нормализация поискового запроса
        if (params.q) {
            params.q = this.normalizeSearchQuery(params.q);
            this.saveToSearchHistory(params.q);
        }

        const cacheKey = this.getCacheKey('search', params);

        // Проверка кеша
        const cached = this.getFromCache(cacheKey);
        if (cached) return cached;

        try {
            const response = await this.request(endpoint, params);

            if (response.success) {
                const result = {
                    success: true,
                    data: {
                        products: response.data?.products || [],
                        total: response.data?.total || 0,
                        page: params.page || 1,
                        limit: params.limit || 20,
                        aggregations: response.data?.aggregations || {},
                        max_score: response.data?.max_score || 0,
                        suggestions: this.generateQuerySuggestions(params.q, response.data)
                    }
                };

                // Постобработка результатов
                this.enhanceSearchResults(result.data, params.q);

                this.saveToCache(cacheKey, result);
                return result;
            }

            return this.errorResponse('Search failed');

        } catch (error) {
            console.error('Search error:', error);
            return this.errorResponse(error.message);
        }
    }

    /**
     * Автодополнение с интеллектуальными предложениями
     */
    async autocomplete(query, limit = 10) {
        if (!query || query.length < 1) {
            // Показываем историю поиска если пусто
            return {
                success: true,
                suggestions: this.getSearchHistorySuggestions(limit)
            };
        }

        query = this.normalizeSearchQuery(query);
        const endpoint = `${this.baseUrl}/autocomplete`;

        try {
            const response = await this.request(endpoint, { q: query, limit }, 3000);

            const suggestions = response.data?.suggestions || [];

            // Добавляем подсказки из истории
            const historySuggestions = this.searchHistory
                .filter(h => h.toLowerCase().includes(query.toLowerCase()))
                .slice(0, 3)
                .map(text => ({
                    text,
                    type: 'history',
                    score: 100
                }));

            // Объединяем и сортируем
            const allSuggestions = [...historySuggestions, ...suggestions]
                .sort((a, b) => (b.score || 0) - (a.score || 0))
                .slice(0, limit);

            return {
                success: true,
                suggestions: allSuggestions
            };

        } catch (error) {
            return { success: false, suggestions: [] };
        }
    }

    /**
     * Поиск с отложенным выполнением (debounce)
     */
    searchDebounced(params = {}) {
        return new Promise((resolve) => {
            clearTimeout(this.searchDebounceTimer);
            this.searchDebounceTimer = setTimeout(async () => {
                const result = await this.search(params);
                resolve(result);
            }, this.searchDebounceTime);
        });
    }

    /**
     * Получить товары по ID с кешированием
     */
    async getProductsByIds(ids, cityId = null) {
        if (!ids.length) return { success: true, data: [] };

        const endpoint = `${this.baseUrl}/products/batch`;
        const cacheKey = this.getCacheKey('batch', { ids: ids.sort(), cityId });

        const cached = this.getFromCache(cacheKey);
        if (cached) return cached;

        try {
            const response = await this.request(endpoint, {
                ids: ids.join(','),
                city_id: cityId || this.getCurrentCityId()
            });

            const result = {
                success: true,
                data: response.data || []
            };

            this.saveToCache(cacheKey, result);
            return result;

        } catch (error) {
            return this.errorResponse(error.message);
        }
    }

    /**
     * Получить один товар
     */
    async getProduct(id, cityId = null) {
        const products = await this.getProductsByIds([id], cityId);
        if (products.success && products.data.length > 0) {
            return {
                success: true,
                data: products.data[0]
            };
        }
        return this.errorResponse('Product not found');
    }

    /**
     * Нормализация поискового запроса
     */
    normalizeSearchQuery(query) {
        return query
            .trim()
            .replace(/\s+/g, ' ')           // Множественные пробелы
            .replace(/['"]/g, '')           // Удаляем кавычки
            .toLowerCase();
    }

    /**
     * Улучшение результатов поиска
     */
    enhanceSearchResults(data, query) {
        if (!query || !data.products.length) return;

        // Добавляем дополнительную информацию к результатам
        data.products.forEach(product => {
            // Подсчитываем релевантность для UI
            product._relevance = this.calculateRelevance(product, query);

            // Маркируем точные совпадения
            if (product.external_id?.toLowerCase() === query) {
                product._exact_match = true;
                product._match_type = 'external_id';
            } else if (product.sku?.toLowerCase() === query) {
                product._exact_match = true;
                product._match_type = 'sku';
            }

            // Форматируем подсветку
            if (product._highlight) {
                product._formatted_name = this.formatHighlight(
                    product.name,
                    product._highlight.name?.[0] || product.name
                );
            }
        });

        // Группируем по типам совпадений для UI
        data.groups = this.groupSearchResults(data.products);
    }

    /**
     * Расчет релевантности для UI
     */
    calculateRelevance(product, query) {
        let score = product._score || 0;

        // Бонусы за различные факторы
        if (product.in_stock) score += 10;
        if (product.popularity_score) score += product.popularity_score * 5;
        if (product._exact_match) score += 100;

        // Штраф за длинное название
        if (product.name && product.name.length > 100) score -= 5;

        return Math.round(score);
    }

    /**
     * Форматирование подсветки
     */
    formatHighlight(original, highlighted) {
        // Заменяем теги подсветки на span с классом
        return highlighted
            .replace(/<mark>/g, '<span class="search-highlight">')
            .replace(/<\/mark>/g, '</span>');
    }

    /**
     * Группировка результатов поиска
     */
    groupSearchResults(products) {
        const groups = {
            exact: [],      // Точные совпадения
            high: [],       // Высокая релевантность
            medium: [],     // Средняя релевантность
            low: []         // Низкая релевантность
        };

        products.forEach(product => {
            if (product._exact_match) {
                groups.exact.push(product);
            } else if (product._relevance > 70) {
                groups.high.push(product);
            } else if (product._relevance > 30) {
                groups.medium.push(product);
            } else {
                groups.low.push(product);
            }
        });

        return groups;
    }

    /**
     * Генерация предложений по улучшению запроса
     */
    generateQuerySuggestions(query, searchData) {
        const suggestions = [];

        if (!query || searchData.total === 0) {
            suggestions.push({
                type: 'tip',
                text: 'Попробуйте изменить запрос или использовать другие слова'
            });
        }

        if (searchData.total < 5 && query.length > 3) {
            // Предлагаем более короткий запрос
            const words = query.split(' ');
            if (words.length > 1) {
                suggestions.push({
                    type: 'alternative',
                    text: `Попробуйте искать: "${words[0]}"`
                });
            }
        }

        return suggestions;
    }

    /**
     * История поиска
     */
    saveToSearchHistory(query) {
        if (!query || query.length < 2) return;

        // Удаляем дубликаты
        this.searchHistory = this.searchHistory.filter(q => q !== query);

        // Добавляем в начало
        this.searchHistory.unshift(query);

        // Ограничиваем размер
        if (this.searchHistory.length > 20) {
            this.searchHistory = this.searchHistory.slice(0, 20);
        }

        // Сохраняем в localStorage
        try {
            localStorage.setItem('searchHistory', JSON.stringify(this.searchHistory));
        } catch (e) {
            console.warn('Failed to save search history');
        }
    }

    loadSearchHistory() {
        try {
            const saved = localStorage.getItem('searchHistory');
            return saved ? JSON.parse(saved) : [];
        } catch (e) {
            return [];
        }
    }

    getSearchHistorySuggestions(limit) {
        return this.searchHistory
            .slice(0, limit)
            .map(text => ({
                text,
                type: 'history',
                score: 50
            }));
    }

    clearSearchHistory() {
        this.searchHistory = [];
        try {
            localStorage.removeItem('searchHistory');
        } catch (e) {}
    }

    /**
     * Универсальный метод запроса с улучшенной обработкой ошибок
     */
    async request(url, params = {}, timeout = null) {
        const controller = new AbortController();
        const requestId = this.generateRequestId();

        const timeoutId = setTimeout(
            () => controller.abort(),
            timeout || this.requestTimeout
        );

        try {
            // Санитизация параметров
            const cleanParams = this.sanitizeParams(params);
            const queryString = new URLSearchParams(cleanParams).toString();
            const fullUrl = queryString ? `${url}?${queryString}` : url;

            console.log(`🔍 [${requestId}] Request: ${fullUrl}`);

            const response = await fetch(fullUrl, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-Request-ID': requestId
                },
                credentials: 'same-origin',
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            // Специальная обработка разных HTTP статусов
            if (!response.ok) {
                await this.handleHttpError(response, fullUrl, requestId);
            }

            const data = await response.json();

            if (!data || typeof data !== 'object') {
                throw new Error('INVALID_RESPONSE_FORMAT');
            }

            console.log(`✅ [${requestId}] Success`);
            return data;

        } catch (error) {
            clearTimeout(timeoutId);
            return await this.handleRequestError(error, url, params, requestId);
        }
    }

    /**
     * Обработка HTTP ошибок
     */
    async handleHttpError(response, fullUrl, requestId) {
        const status = response.status;
        let errorDetails = `HTTP ${status}`;

        try {
            const errorBody = await response.text();
            if (errorBody) {
                errorDetails += `: ${errorBody.substring(0, 200)}`;
            }
        } catch (e) {
            // Игнорируем ошибки чтения body
        }

        console.error(`❌ [${requestId}] ${errorDetails}`);

        switch (status) {
            case 503:
                throw new Error('SERVICE_TEMPORARILY_UNAVAILABLE');
            case 502:
            case 504:
                throw new Error('GATEWAY_ERROR');
            case 429:
                throw new Error('RATE_LIMIT_EXCEEDED');
            case 400:
                throw new Error('BAD_REQUEST');
            default:
                throw new Error(`HTTP_${status}`);
        }
    }

    /**
     * Интеллектуальная обработка ошибок запроса
     */
    async handleRequestError(error, url, params, requestId) {
        console.error(`❌ [${requestId}] Error:`, error.message);

        // Специальная обработка для 503
        if (error.message === 'SERVICE_TEMPORARILY_UNAVAILABLE') {
            return await this.handle503Error(url, params, requestId);
        }

        if (error.name === 'AbortError') {
            return await this.handleTimeoutError(url, params, requestId);
        }

        // Общая fallback стратегия
        return this.getFallbackResponse(error, params);
    }

    /**
     * Специальная обработка 503 ошибок
     */
    async handle503Error(url, params, requestId) {
        console.warn(`⚠️ [${requestId}] Service unavailable, trying fallback strategies`);

        // Стратегия 1: Проверяем кеш
        const cacheKey = this.getCacheKey('search', params);
        const cached = this.getFromCache(cacheKey);

        if (cached) {
            console.log(`💾 [${requestId}] Using cache`);
            return {
                ...cached,
                warning: 'Показаны результаты из кеша - сервис поиска временно недоступен',
                fallback_used: 'cache'
            };
        }

        // Стратегия 2: Упрощенный запрос
        if (params.q && params.q.length > 5) {
            console.log(`🔄 [${requestId}] Trying simplified request`);

            try {
                const simplifiedParams = {
                    ...params,
                    q: params.q.substring(0, Math.min(10, params.q.length)),
                    limit: Math.min(params.limit || 20, 10)
                };

                // Даем еще одну попытку с упрощенными параметрами
                await new Promise(resolve => setTimeout(resolve, 1000)); // Пауза 1 сек

                const result = await this.makeSimpleRequest(url, simplifiedParams);
                return {
                    ...result,
                    warning: 'Показаны результаты упрощенного поиска',
                    fallback_used: 'simplified'
                };

            } catch (e) {
                console.warn(`⚠️ [${requestId}] Simplified request also failed`);
            }
        }

        // Стратегия 3: Возвращаем graceful fallback
        return this.getFallbackResponse(new Error('Service temporarily unavailable'), params);
    }

    /**
     * Упрощенный запрос
     */
    async makeSimpleRequest(url, params) {
        const controller = new AbortController();
        setTimeout(() => controller.abort(), 5000); // Короткий timeout

        const queryString = new URLSearchParams(params).toString();
        const fullUrl = `${url}?${queryString}`;

        const response = await fetch(fullUrl, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            signal: controller.signal
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        return await response.json();
    }

    /**
     * Санитизация параметров
     */
    sanitizeParams(params) {
        const sanitized = {};

        Object.entries(params).forEach(([key, value]) => {
            if (value !== null && value !== undefined && value !== '') {
                switch (key) {
                    case 'q':
                        // Очищаем поисковый запрос
                        sanitized[key] = String(value)
                            .trim()
                            .replace(/[<>'"\\]/g, '')
                            .replace(/\s+/g, ' ')
                            .substring(0, 200);
                        break;
                    case 'page':
                    case 'limit':
                    case 'city_id':
                        const numValue = parseInt(value);
                        if (!isNaN(numValue) && numValue > 0) {
                            sanitized[key] = numValue;
                        }
                        break;
                    case 'sort':
                        const allowedSorts = ['relevance', 'name', 'price_asc', 'price_desc', 'availability', 'popularity'];
                        if (allowedSorts.includes(value)) {
                            sanitized[key] = value;
                        }
                        break;
                    default:
                        sanitized[key] = value;
                }
            }
        });

        return sanitized;
    }

    generateRequestId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    /**
     * Генерация ответа при ошибке
     */
    errorResponse(message) {
        return {
            success: false,
            error: message,
            data: {
                products: [],
                total: 0
            }
        };
    }

    /**
     * Предзагрузка популярных товаров
     */
    async preloadPopularProducts() {
        const params = {
            sort: 'popularity',
            limit: 20
        };

        try {
            await this.search(params);
        } catch (e) {
            console.warn('Failed to preload popular products');
        }
    }
}

// Экспорт синглтона
export const productService = new ProductService();

// Автоматическая предзагрузка при инициализации
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        productService.preloadPopularProducts();
    });
}

/var/www/www-root/data/site/vdestor.ru/src/js/availability.js
import { showToast } from "./utils.js";

/**
 * Сервис для работы с наличием товаров
 * Оптимизированная версия с батчингом и кешированием
 */
class AvailabilityService {
    constructor() {
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5 минут
        this.batchSize = 100;
        this.apiUrl = '/api/availability';
    }

    /**
     * Загрузить данные о наличии для массива товаров
     */
    async loadAvailability(productIds) {
        if (!Array.isArray(productIds) || !productIds.length) {
            console.warn('loadAvailability: нет товаров для проверки');
            return {};
        }

        const cityId = this.getCurrentCityId();
        const uniqueIds = [...new Set(productIds)];

        // Проверяем кеш
        const cached = this.checkCache(uniqueIds, cityId);
        const idsToLoad = cached.missing;

        if (!idsToLoad.length) {
            this.updateUI(cached.data);
            return cached.data;
        }

        // Загружаем отсутствующие в кеше
        const loadedData = await this.fetchBatched(idsToLoad, cityId);

        // Объединяем с кешированными
        const allData = { ...cached.data, ...loadedData };

        // Обновляем UI
        this.updateUI(allData);

        return allData;
    }

    /**
     * Загрузка с разбивкой на батчи
     */
    async fetchBatched(productIds, cityId) {
        const batches = this.createBatches(productIds);
        const results = await Promise.all(
            batches.map(batch => this.fetchBatch(batch, cityId))
        );

        return Object.assign({}, ...results);
    }

    /**
     * Загрузка одного батча
     */
    async fetchBatch(productIds, cityId) {
        try {
            // Создаем параметры URL
            const params = new URLSearchParams({
                city_id: cityId,
                product_ids: productIds.join(',')
            });

            // Формируем URL с параметрами
            const url = `${this.apiUrl}?${params.toString()}`;

            // Правильный GET-запрос без тела
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                credentials: 'same-origin'
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const result = await response.json();

            if (result.success && result.data) {
                this.saveToCache(result.data, cityId);
                return result.data;
            }

            return {};

        } catch (error) {
            console.error('Ошибка загрузки батча:', error);
            return {};
        }
    }

    /**
     * Обновление UI элементов
     */
    updateUI(data) {
        Object.entries(data).forEach(([productId, info]) => {
            // Ищем элементы как по data-product-id атрибуту, так и по классам
            const rows = document.querySelectorAll(`[data-product-id="${productId}"]`);

            rows.forEach(row => {
                // Наличие - используем единый формат
                const availCells = row.querySelectorAll('.availability-cell, .col-availability span, .product-availability .availability-text');
                availCells.forEach(cell => {
                    if (cell) {
                        const text = info.availability_text || (info.quantity > 0 ? `${info.quantity} шт.` : 'Нет');
                        cell.textContent = text;

                        // Обновляем классы для визуального отображения
                        if (cell.classList.contains('availability-cell') || cell.parentElement.classList.contains('col-availability')) {
                            cell.className = info.quantity > 10 ? 'text-success' : info.quantity > 0 ? 'text-warning' : 'text-danger';
                        }

                        // Для карточек товаров
                        const availabilityBlock = cell.closest('.product-availability');
                        if (availabilityBlock) {
                            availabilityBlock.classList.remove('in-stock', 'out-of-stock');
                            availabilityBlock.classList.add(info.quantity > 0 ? 'in-stock' : 'out-of-stock');
                        }
                    }
                });

                // Дата доставки
                const dateCells = row.querySelectorAll('.delivery-date-cell, .col-delivery-date span');
                dateCells.forEach(cell => {
                    if (cell) {
                        cell.textContent = info.delivery_text || info.delivery_date || '—';
                    }
                });

                // Обновляем цены если они пришли
                if (info.price !== undefined && info.price !== null) {
                    const priceCells = row.querySelectorAll('.product-price, .col-price span');
                    priceCells.forEach(cell => {
                        if (cell) {
                            cell.textContent = `${info.price.toFixed(2)} ₽`;
                        }
                    });
                }

                // Обновляем кнопку "В корзину"
                const addToCartBtns = row.querySelectorAll('.btn-add-to-cart, .add-to-cart-btn');
                addToCartBtns.forEach(btn => {
                    if (btn) {
                        btn.disabled = info.quantity === 0;
                    }
                });
            });
        });
    }

    /**
     * Работа с кешем
     */
    checkCache(productIds, cityId) {
        const data = {};
        const missing = [];
        const now = Date.now();

        productIds.forEach(id => {
            const key = `${cityId}_${id}`;
            const cached = this.cache.get(key);

            if (cached && (now - cached.timestamp < this.cacheTimeout)) {
                data[id] = cached.data;
            } else {
                missing.push(id);
            }
        });

        return { data, missing };
    }

    saveToCache(data, cityId) {
        const now = Date.now();
        Object.entries(data).forEach(([productId, info]) => {
            const key = `${cityId}_${productId}`;
            this.cache.set(key, {
                data: info,
                timestamp: now
            });
        });

        // Ограничиваем размер кеша
        if (this.cache.size > 1000) {
            const oldestKeys = Array.from(this.cache.entries())
                .sort((a, b) => a[1].timestamp - b[1].timestamp)
                .slice(0, 100)
                .map(([key]) => key);

            oldestKeys.forEach(key => this.cache.delete(key));
        }
    }

    /**
     * Утилиты
     */
    getCurrentCityId() {
        return document.getElementById('citySelect')?.value || '1';
    }

    createBatches(items) {
        const batches = [];
        for (let i = 0; i < items.length; i += this.batchSize) {
            batches.push(items.slice(i, i + this.batchSize));
        }
        return batches;
    }

    clearCache() {
        this.cache.clear();
    }
}

// Экспорт синглтона
export const availabilityService = new AvailabilityService();

// Обратная совместимость
export async function loadAvailability(ids) {
    return availabilityService.loadAvailability(ids);
}/var/www/www-root/data/site/vdestor.ru/src/js/cart.js
import { showToast } from "./utils.js";

export async function fetchCart() {
    try {
        const res = await fetch("/cart/json");
        if (!res.ok) throw new Error("Ошибка загрузки корзины");
        const data = await res.json();
        window.cart = data.cart || {};
    } catch (err) {
        showToast("Ошибка при загрузке корзины", true);
    }
}

export async function addToCart(productId, quantity) {
    try {
        const formData = new FormData();
        formData.append('product_id', productId);
        formData.append('quantity', quantity);
        formData.append('csrf_token', window.CSRF_TOKEN || '');

        const res = await fetch("/cart/add", {
            method: "POST",
            body: formData
        });

        if (!res.ok) throw new Error("Ошибка добавления в корзину");

        const data = await res.json();
        if (data.success) {
            showToast("Товар добавлен в корзину");
            await fetchCart();
        } else {
            showToast(data.message || "Ошибка при добавлении в корзину", true);
        }
    } catch (err) {
        showToast("Ошибка при добавлении в корзину", true);
    }
}

export async function removeFromCart(productId) {
    try {
        const formData = new FormData();
        formData.append('productId', productId);
        formData.append('csrf_token', window.CSRF_TOKEN || '');

        const res = await fetch("/cart/remove", {
            method: "POST",
            body: formData
        });

        if (!res.ok) throw new Error("Ошибка удаления из корзины");

        const data = await res.json();
        if (data.success) {
            showToast("Товар удален из корзины");
            await fetchCart();
        } else {
            showToast(data.message || "Ошибка при удалении из корзины", true);
        }
    } catch (err) {
        showToast("Ошибка при удалении из корзины", true);
    }
}

export async function clearCart() {
    try {
        const formData = new FormData();
        formData.append('csrf_token', window.CSRF_TOKEN || '');

        const res = await fetch("/cart/clear", {
            method: "POST",
            body: formData
        });

        if (!res.ok) throw new Error("Ошибка очистки корзины");

        const data = await res.json();
        if (data.success) {
            showToast("Корзина очищена");
            await fetchCart();
        } else {
            showToast(data.message || "Ошибка при очистке корзины", true);
        }
    } catch (err) {
        showToast("Ошибка при очистке корзины", true);
    }
}

/var/www/www-root/data/site/vdestor.ru/src/Controllers/ProductController.php
<?php
namespace App\Controllers;

use App\Core\Database;
use App\Core\Layout;
use App\Core\Logger;
use App\Services\DynamicProductDataService;
use App\Services\AuthService;
use App\Services\SearchService;

class ProductController
{
    /**
     * Просмотр одного товара с динамической загрузкой данных
     */
    public function viewAction()
    {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            $this->show404();
            return;
        }

        $pdo = Database::getConnection();

        // 1. Получаем основные статические данные товара
        $stmt = $pdo->prepare("
            SELECT p.*, b.name AS brand_name, s.name AS series_name
            FROM products p
            LEFT JOIN brands b ON b.brand_id = p.brand_id
            LEFT JOIN series s ON s.series_id = p.series_id
            WHERE p.product_id = :id OR p.external_id = :id
            LIMIT 1
        ");
        $stmt->execute(['id' => $id]);
        $product = $stmt->fetch();

        if (!$product) {
            $this->show404();
            return;
        }

        $productId = $product['product_id'];

        // 2. Получаем дополнительные статические данные
        $images = $this->getProductImages($productId);
        $documents = $this->getProductDocuments($productId);
        $attributes = $this->getProductAttributes($productId);
        $related = $this->getRelatedProducts($productId);

        // 3. Получаем динамические данные (цены, остатки, доставка)
        $cityId = (int)($_COOKIE['selected_city_id'] ?? $_SESSION['city_id'] ?? 1);
        $userId = AuthService::check() ? AuthService::user()['id'] : null;

        $dynamicService = new DynamicProductDataService();
        $dynamicData = $dynamicService->getProductsDynamicData([$productId], $cityId, $userId);
        $productDynamic = $dynamicData[$productId] ?? [];

        // 4. Извлекаем данные для передачи в view
        $price = $productDynamic['price']['final'] ?? null;
        $basePrice = $productDynamic['price']['base'] ?? null;
        $hasSpecialPrice = $productDynamic['price']['has_special'] ?? false;
        $stock = $productDynamic['stock']['quantity'] ?? 0;
        $availableWarehouses = $productDynamic['stock']['warehouses'] ?? [];
        $deliveryInfo = $productDynamic['delivery'] ?? ['text' => 'Уточняйте'];

        // 5. Логируем просмотр товара для аналитики
        $this->logProductView($productId, $userId);

        // 6. Передаем все данные в view
        Layout::render('shop/product', [
            'product' => $product,
            'images' => $images,
            'documents' => $documents,
            'attributes' => $attributes,
            'price' => $price,
            'basePrice' => $basePrice,
            'hasSpecialPrice' => $hasSpecialPrice,
            'stock' => $stock,
            'availableWarehouses' => $availableWarehouses,
            'deliveryInfo' => $deliveryInfo,
            'related' => $related,
            'cityId' => $cityId,
            'productDynamic' => $productDynamic // Полные динамические данные для JS
        ]);
    }

    /**
     * Получение изображений товара
     */
    private function getProductImages(int $productId): array
    {
        $stmt = Database::query(
            "SELECT url, alt_text, is_main FROM product_images
             WHERE product_id = ?
             ORDER BY is_main DESC, sort_order ASC",
            [$productId]
        );
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * Получение документов товара
     */
    private function getProductDocuments(int $productId): array
    {
        $stmt = Database::query(
            "SELECT * FROM product_documents
             WHERE product_id = ?
             ORDER BY type, document_id",
            [$productId]
        );
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * Получение атрибутов товара
     */
    private function getProductAttributes(int $productId): array
    {
        $stmt = Database::query(
            "SELECT name, value, unit FROM product_attributes
             WHERE product_id = ?
             ORDER BY sort_order ASC",
            [$productId]
        );
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * Получение связанных товаров
     */
    private function getRelatedProducts(int $productId): array
    {
        $stmt = Database::query(
            "SELECT p.product_id, p.name, p.external_id, p.sku,
                    pr.price as base_price,
                    COALESCE(pi.url, '/images/placeholder.jpg') as image_url
             FROM related_products rp
             JOIN products p ON p.product_id = rp.related_id
             LEFT JOIN prices pr ON pr.product_id = p.product_id AND pr.is_base = 1
             LEFT JOIN product_images pi ON pi.product_id = p.product_id AND pi.is_main = 1
             WHERE rp.product_id = ?
             ORDER BY rp.sort_order, rp.relation_type",
            [$productId]
        );
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * Логирование просмотра товара
     */
    private function logProductView(int $productId, ?int $userId): void
    {
        try {
            // Обновляем счетчик просмотров
            Database::query(
                "INSERT INTO product_metrics (product_id, views_count)
                 VALUES (?, 1)
                 ON DUPLICATE KEY UPDATE views_count = views_count + 1",
                [$productId]
            );

            // Логируем в audit_logs
            Database::query(
                "INSERT INTO audit_logs (user_id, session_id, action, object_type, object_id, created_at)
                 VALUES (?, ?, 'view', 'product', ?, NOW())",
                [$userId, session_id(), $productId]
            );
        } catch (\Exception $e) {
            Logger::warning('Failed to log product view', ['error' => $e->getMessage()]);
        }
    }

    /**
     * Показ 404 страницы
     */
    private function show404(): void
    {
        http_response_code(404);
        Layout::render('errors/404', []);
    }

    /**
     * AJAX endpoint для динамического обновления данных о товаре
     */
    public function ajaxProductInfoAction(): void
    {
        header('Content-Type: application/json; charset=utf-8');

        $productId = (int)($_GET['id'] ?? 0);
        $cityId = (int)($_GET['city_id'] ?? 1);

        if ($productId <= 0) {
            $this->jsonResponse(['success' => false, 'error' => 'Invalid product ID']);
            return;
        }

        $userId = AuthService::check() ? AuthService::user()['id'] : null;

        try {
            $dynamicService = new DynamicProductDataService();
            $dynamicData = $dynamicService->getProductsDynamicData([$productId], $cityId, $userId);

            $this->jsonResponse([
                'success' => true,
                'data' => $dynamicData[$productId] ?? []
            ]);
        } catch (\Exception $e) {
            Logger::error('Failed to get product info', ['error' => $e->getMessage()]);
            $this->jsonResponse(['success' => false, 'error' => 'Server error']);
        }
    }

    /**
     * Каталог товаров (список)
     */
    public function catalogAction(): void
    {
        Layout::render('shop/index', []);
    }

    /**
     * Поиск товаров
     */
    public function searchAction(): void
    {
        $query = trim($_GET['q'] ?? '');

        if (empty($query)) {
            Layout::render('shop/search', ['products' => [], 'query' => '']);
            return;
        }

        $params = [
            'q' => $query,
            'page' => (int)($_GET['page'] ?? 1),
            'limit' => (int)($_GET['limit'] ?? 20),
            'city_id' => (int)($_GET['city_id'] ?? 1),
            'sort' => $_GET['sort'] ?? 'relevance'
        ];

        if (AuthService::check()) {
            $params['user_id'] = AuthService::user()['id'];
        }

        $result = SearchService::search($params);

        Layout::render('shop/search', [
            'products' => $result['data']['products'] ?? [],
            'query' => $query,
            'total' => $result['data']['total'] ?? 0,
            'currentPage' => $params['page'],
            'totalPages' => ceil(($result['data']['total'] ?? 0) / $params['limit'])
        ]);
    }

    /**
     * Вспомогательный метод для JSON ответов
     */
    private function jsonResponse(array $data): void
    {
        echo json_encode($data, JSON_UNESCAPED_UNICODE);
        exit;
    }
}

/var/www/www-root/data/site/vdestor.ru/src/Services/SearchService.php
<?php
namespace App\Services;

use App\Core\Database;
use App\Core\Logger;
use App\Core\Cache;
use OpenSearch\ClientBuilder;

class SearchService
{
    private static ?\OpenSearch\Client $client = null;

    public static function search(array $params): array
    {
        $requestId = uniqid('search_', true);
        $startTime = microtime(true);

        Logger::info("🔍 [$requestId] Search started", ['params' => $params]);

        try {
            $params = self::validateParams($params);

            // Проверяем ресурсы системы
            if (!self::checkSystemResources()) {
                throw new \Exception("System overloaded");
            }

            // Проверяем OpenSearch с новой логикой
            if (self::isOpenSearchAvailable()) {
                Logger::debug("✅ [$requestId] Using OpenSearch");
                $result = self::performOpenSearchWithTimeout($params, $requestId);

                $duration = round((microtime(true) - $startTime) * 1000, 2);
                Logger::info("✅ [$requestId] Completed in {$duration}ms");

                return [
                    'success' => true,
                    'data' => $result
                ];
            } else {
                Logger::warning("⚠️ [$requestId] OpenSearch unavailable, using MySQL");
                $result = self::searchViaMySQL($params);
                return [
                    'success' => true,
                    'data' => $result
                ];
            }

        } catch (\Exception $e) {
            $duration = round((microtime(true) - $startTime) * 1000, 2);
            Logger::error("❌ [$requestId] Failed after {$duration}ms", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            // Правильный HTTP статус и структурированный ответ
            http_response_code(503);
            return [
                'success' => false,
                'error' => 'Search service temporarily unavailable',
                'error_code' => 'SERVICE_UNAVAILABLE',
                'data' => [
                    'products' => [],
                    'total' => 0,
                    'page' => $params['page'] ?? 1,
                    'limit' => $params['limit'] ?? 20,
                    'debug_info' => [
                        'request_id' => $requestId,
                        'duration_ms' => $duration,
                        'timestamp' => date('c')
                    ]
                ]
            ];
        }
    }

    /**
     * Построение основного запроса с учетом всех условий
     */
    private static function buildMainQuery(string $query, array $words, bool $isArticul): array
    {
        $should = [];

        // 1. Точное совпадение артикула/SKU (максимальный приоритет)
        if ($isArticul) {
            $should[] = ['term' => ['external_id.keyword' => ['value' => $query, 'boost' => 1000]]];
            $should[] = ['term' => ['sku.keyword' => ['value' => $query, 'boost' => 900]]];
        }

        // 2. Префиксный поиск по артикулу
        $should[] = ['prefix' => ['external_id' => ['value' => $query, 'boost' => 100]]];
        $should[] = ['prefix' => ['sku' => ['value' => $query, 'boost' => 90]]];

        // 3. Поиск по артикулу с учетом ошибок (fuzzy)
        $should[] = [
            'fuzzy' => [
                'external_id' => [
                    'value' => $query,
                    'fuzziness' => 'AUTO',
                    'prefix_length' => 2,
                    'boost' => 80
                ]
            ]
        ];

        // 4. Точная фраза в названии
        $should[] = ['match_phrase' => ['name' => ['query' => $query, 'boost' => 70]]];

        // 5. Все слова должны присутствовать (AND)
        $should[] = [
            'match' => [
                'name' => [
                    'query' => $query,
                    'operator' => 'and',
                    'boost' => 60
                ]
            ]
        ];

        // 6. Поиск с учетом опечаток в названии
        $should[] = [
            'match' => [
                'name' => [
                    'query' => $query,
                    'fuzziness' => 'AUTO',
                    'prefix_length' => 3,
                    'boost' => 40
                ]
            ]
        ];

        // 7. Multi-match по всем важным полям
        $should[] = [
            'multi_match' => [
                'query' => $query,
                'fields' => [
                    'name^5',
                    'name.ngram^2',
                    'brand_name^3',
                    'series_name^2',
                    'description'
                ],
                'type' => 'best_fields',
                'fuzziness' => 'AUTO',
                'prefix_length' => 2,
                'boost' => 30
            ]
        ];

        // 8. Поиск по отдельным словам (для разбросанных слов)
        if (count($words) > 1) {
            $wordQueries = [];
            foreach ($words as $word) {
                if (mb_strlen($word) >= 2) {
                    $wordQueries[] = [
                        'multi_match' => [
                            'query' => $word,
                            'fields' => ['name^3', 'brand_name^2', 'description'],
                            'fuzziness' => 'AUTO',
                            'prefix_length' => 1
                        ]
                    ];
                }
            }

            $should[] = [
                'bool' => [
                    'should' => $wordQueries,
                    'minimum_should_match' => ceil(count($words) * 0.7),
                    'boost' => 20
                ]
            ];
        }

        // 9. N-gram поиск для частичных совпадений
        $should[] = [
            'match' => [
                'name.ngram' => [
                    'query' => $query,
                    'boost' => 10
                ]
            ]
        ];

        // 10. Wildcard поиск (последний вариант)
        if (mb_strlen($query) >= 3 && !$isArticul) {
            $should[] = [
                'wildcard' => [
                    'name.keyword' => [
                        'value' => "*{$query}*",
                        'boost' => 5
                    ]
                ]
            ];
        }

        return [
            'bool' => [
                'should' => $should,
                'minimum_should_match' => 1
            ]
        ];
    }

    /**
     * Функции скоринга для точной настройки релевантности
     */
    private static function buildScoringFunctions(string $query, bool $isArticul): array
    {
        $functions = [];

        // Бонус за популярность
        $functions[] = [
            'field_value_factor' => [
                'field' => 'popularity_score',
                'factor' => 1.2,
                'modifier' => 'log1p',
                'missing' => 0
            ],
            'weight' => 10
        ];

        // Бонус за наличие на складе
        $functions[] = [
            'filter' => ['term' => ['in_stock' => true]],
            'weight' => 5
        ];

        // Бонус за короткое название (обычно более релевантно)
        $functions[] = [
            'script_score' => [
                'script' => [
                    'source' => "Math.max(1, 50 - doc['name.keyword'].value.length()) / 50"
                ]
            ],
            'weight' => 3
        ];

        // Штраф за слишком длинное описание
        $functions[] = [
            'script_score' => [
                'script' => [
                    'source' => "
                        if (doc.containsKey('description') && doc['description'].size() > 0) {
                            return Math.max(0.5, 1 - (doc['description'].value.length() / 1000.0));
                        }
                        return 1;
                    "
                ]
            ],
            'weight' => 2
        ];

        return $functions;
    }

    /**
     * Автодополнение с исправлением ошибок
     */
    public static function autocomplete(string $query, int $limit = 10): array
    {
        $query = mb_strtolower(trim($query));
        if (mb_strlen($query) < 1) return [];

        try {
            if (!self::isOpenSearchAvailable()) {
                return self::autocompleteMysql($query, $limit);
            }

            // Используем suggest API для автодополнения
            $body = [
                'suggest' => [
                    'product-suggest' => [
                        'prefix' => $query,
                        'completion' => [
                            'field' => 'suggest',
                            'size' => $limit,
                            'fuzzy' => [
                                'fuzziness' => 'AUTO',
                                'prefix_length' => 1
                            ],
                            'contexts' => []
                        ]
                    ]
                ],
                // Дополнительно ищем по обычным полям
                'size' => $limit,
                '_source' => ['name', 'external_id', 'brand_name'],
                'query' => [
                    'bool' => [
                        'should' => [
                            ['prefix' => ['external_id' => ['value' => $query, 'boost' => 10]]],
                            ['prefix' => ['name.autocomplete' => ['value' => $query, 'boost' => 5]]],
                            ['match_phrase_prefix' => ['name' => ['query' => $query, 'boost' => 3]]],
                            ['fuzzy' => ['name' => ['value' => $query, 'fuzziness' => 'AUTO', 'boost' => 2]]],
                            ['prefix' => ['brand_name.autocomplete' => ['value' => $query, 'boost' => 2]]]
                        ]
                    ]
                ]
            ];

            $response = self::getClient()->search([
                'index' => 'products_current',
                'body' => $body
            ]);

            $suggestions = [];
            $seen = [];

            // Обрабатываем suggest результаты
            if (isset($response['suggest']['product-suggest'][0]['options'])) {
                foreach ($response['suggest']['product-suggest'][0]['options'] as $option) {
                    $text = $option['text'];
                    $key = mb_strtolower($text);

                    if (!isset($seen[$key])) {
                        $suggestions[] = [
                            'text' => $text,
                            'type' => 'suggest',
                            'score' => $option['_score'] ?? 1
                        ];
                        $seen[$key] = true;
                    }
                }
            }

            // Добавляем результаты из обычного поиска
            foreach ($response['hits']['hits'] ?? [] as $hit) {
                $source = $hit['_source'];
                $text = $source['name'];
                $key = mb_strtolower($text);

                if (!isset($seen[$key])) {
                    $suggestions[] = [
                        'text' => $text,
                        'type' => 'product',
                        'score' => $hit['_score'],
                        'external_id' => $source['external_id'] ?? null
                    ];
                    $seen[$key] = true;

                    if (count($suggestions) >= $limit) break;
                }
            }

            // Сортируем по score
            usort($suggestions, function($a, $b) {
                return ($b['score'] ?? 0) <=> ($a['score'] ?? 0);
            });

            return array_slice($suggestions, 0, $limit);

        } catch (\Exception $e) {
            Logger::warning('Autocomplete error', ['error' => $e->getMessage()]);
            return self::autocompleteMysql($query, $limit);
        }
    }

    /**
     * Определение является ли запрос артикулом
     */
    private static function isArticul(string $query): bool
    {
        // Артикул обычно содержит цифры и может иметь дефисы, точки
        return preg_match('/^[A-Za-z0-9\-\.\/]+$/', $query) &&
               preg_match('/\d/', $query) &&
               mb_strlen($query) <= 50;
    }

    private static function buildSort(string $sort, bool $hasQuery): array
    {
        switch ($sort) {
            case 'name':
                return [['name.keyword' => 'asc']];
            case 'external_id':
                return [['external_id.keyword' => 'asc']];
            case 'price_asc':
                return [['product_id' => 'asc']]; // Заменить на реальное поле цены
            case 'price_desc':
                return [['product_id' => 'desc']];
            case 'availability':
                return [['in_stock' => 'desc'], ['_score' => 'desc']];
            case 'popularity':
                return [['popularity_score' => 'desc'], ['_score' => 'desc']];
            case 'relevance':
            default:
                if ($hasQuery) {
                    return [['_score' => 'desc'], ['popularity_score' => 'desc']];
                } else {
                    return [['popularity_score' => 'desc'], ['name.keyword' => 'asc']];
                }
        }
    }

    private static function processResponse(array $response, array $params): array
    {
        $products = [];

        foreach ($response['hits']['hits'] ?? [] as $hit) {
            $product = $hit['_source'];
            $product['_score'] = $hit['_score'] ?? 0;

            if (isset($hit['highlight'])) {
                $product['_highlight'] = $hit['highlight'];
            }

            $products[] = $product;
        }

        // Обогащаем динамическими данными
        if (!empty($products)) {
            $productIds = array_column($products, 'product_id');
            $cityId = $params['city_id'] ?? 1;
            $userId = $params['user_id'] ?? null;

            try {
                $dynamicService = new DynamicProductDataService();
                $dynamicData = $dynamicService->getProductsDynamicData($productIds, $cityId, $userId);

                foreach ($products as &$product) {
                    $pid = $product['product_id'];
                    if (isset($dynamicData[$pid])) {
                        $product = array_merge($product, $dynamicData[$pid]);
                    }
                }
            } catch (\Exception $e) {
                Logger::warning('Failed to enrich products', ['error' => $e->getMessage()]);
            }
        }

        return [
            'products' => $products,
            'total' => $response['hits']['total']['value'] ?? 0,
            'page' => $params['page'],
            'limit' => $params['limit']
        ];
    }

    /**
     * MySQL fallback с улучшенной логикой
     */
    private static function searchViaMySQL(array $params): array
    {
        $query = $params['q'] ?? '';
        $page = $params['page'];
        $limit = $params['limit'];
        $offset = ($page - 1) * $limit;

        try {
            $pdo = Database::getConnection();

            $sql = "SELECT SQL_CALC_FOUND_ROWS
                    p.product_id, p.external_id, p.sku, p.name, p.description,
                    p.brand_id, p.series_id, p.unit, p.min_sale, p.weight, p.dimensions,
                    b.name as brand_name, s.name as series_name,
                    CASE
                        WHEN p.external_id = :exact_q THEN 1000
                        WHEN p.sku = :exact_q THEN 900
                        WHEN p.external_id LIKE :prefix_q THEN 100
                        WHEN p.sku LIKE :prefix_q THEN 90
                        WHEN p.name = :exact_q THEN 80
                        WHEN p.name LIKE :prefix_q THEN 50
                        WHEN p.name LIKE :search_q THEN 30
                        WHEN p.description LIKE :search_q THEN 10
                        WHEN b.name LIKE :search_q THEN 20
                        ELSE 1
                    END as relevance_score
                    FROM products p
                    LEFT JOIN brands b ON p.brand_id = b.brand_id
                    LEFT JOIN series s ON p.series_id = s.series_id
                    WHERE 1=1";

            $bindParams = [];

            if (!empty($query)) {
                $sql .= " AND (
                    p.external_id = :exact_q OR
                    p.sku = :exact_q OR
                    p.external_id LIKE :prefix_q OR
                    p.sku LIKE :prefix_q OR
                    p.name LIKE :search_q OR
                    p.description LIKE :search_q OR
                    b.name LIKE :search_q
                )";

                $bindParams['exact_q'] = $query;
                $bindParams['prefix_q'] = $query . '%';
                $bindParams['search_q'] = '%' . $query . '%';
            }

            // Сортировка
            switch ($params['sort']) {
                case 'name':
                    $sql .= " ORDER BY p.name ASC";
                    break;
                case 'external_id':
                    $sql .= " ORDER BY p.external_id ASC";
                    break;
                default:
                    if (!empty($query)) {
                        $sql .= " ORDER BY relevance_score DESC, p.name ASC";
                    } else {
                        $sql .= " ORDER BY p.name ASC";
                    }
                    break;
            }

            $sql .= " LIMIT :limit OFFSET :offset";

            $stmt = $pdo->prepare($sql);
            foreach ($bindParams as $key => $value) {
                $stmt->bindValue($key, $value);
            }
            $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
            $stmt->bindValue(':offset', $offset, \PDO::PARAM_INT);
            $stmt->execute();

            $products = $stmt->fetchAll();
            $total = $pdo->query("SELECT FOUND_ROWS()")->fetchColumn();

            return [
                'products' => $products,
                'total' => (int)$total,
                'page' => $page,
                'limit' => $limit
            ];

        } catch (\Exception $e) {
            Logger::error('MySQL search failed', ['error' => $e->getMessage()]);
            return [
                'products' => [],
                'total' => 0,
                'page' => $page,
                'limit' => $limit
            ];
        }
    }

    private static function autocompleteMysql(string $query, int $limit): array
    {
        try {
            $pdo = Database::getConnection();

            // Используем SOUNDEX для поиска похожих по звучанию слов
            $stmt = $pdo->prepare("
                SELECT DISTINCT p.name, p.external_id,
                    CASE
                        WHEN p.external_id LIKE :exact THEN 100
                        WHEN p.external_id LIKE :prefix THEN 90
                        WHEN p.name LIKE :prefix THEN 50
                        WHEN p.name LIKE :anywhere THEN 30
                        WHEN SOUNDEX(p.name) = SOUNDEX(:soundex) THEN 20
                        ELSE 10
                    END as score
                FROM products p
                LEFT JOIN brands b ON p.brand_id = b.brand_id
                WHERE p.external_id LIKE :prefix OR
                      p.name LIKE :anywhere OR
                      b.name LIKE :prefix OR
                      SOUNDEX(p.name) = SOUNDEX(:soundex)
                ORDER BY score DESC, p.name ASC
                LIMIT :limit
            ");

            $stmt->bindValue(':exact', $query);
            $stmt->bindValue(':prefix', $query . '%');
            $stmt->bindValue(':anywhere', '%' . $query . '%');
            $stmt->bindValue(':soundex', $query);
            $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
            $stmt->execute();

            $suggestions = [];
            while ($row = $stmt->fetch()) {
                $suggestions[] = [
                    'text' => $row['name'],
                    'type' => 'product',
                    'external_id' => $row['external_id'],
                    'score' => $row['score']
                ];
            }

            return $suggestions;

        } catch (\Exception $e) {
            Logger::error('MySQL autocomplete failed', ['error' => $e->getMessage()]);
            return [];
        }
    }

    private static function validateParams(array $params): array
    {
        return [
            'q' => trim($params['q'] ?? ''),
            'page' => max(1, (int)($params['page'] ?? 1)),
            'limit' => min(100, max(1, (int)($params['limit'] ?? 20))),
            'city_id' => (int)($params['city_id'] ?? 1),
            'sort' => $params['sort'] ?? 'relevance',
            'user_id' => $params['user_id'] ?? null
        ];
    }

    private static function isOpenSearchAvailable(): bool
    {
        static $isAvailable = null;
        static $lastCheck = 0;
        static $consecutiveFailures = 0;

        // Периодически перепроверяем статус
        $checkInterval = min(300, 30 + ($consecutiveFailures * 10)); // От 30 до 300 сек

        if ($isAvailable !== null && (time() - $lastCheck) < $checkInterval) {
            return $isAvailable;
        }

        try {
            $startTime = microtime(true);
            $client = self::getClient();

            // Быстрая проверка с timeout
            $health = $client->cluster()->health([
                'timeout' => '5s',
                'wait_for_status' => null
            ]);

            $responseTime = (microtime(true) - $startTime) * 1000;

            // Проверяем и статус, и время отклика
            $acceptableStatuses = ['green', 'yellow'];
            $clusterStatus = $health['status'] ?? 'red';

            $isAvailable = in_array($clusterStatus, $acceptableStatuses) && $responseTime < 5000;

            if ($isAvailable) {
                $consecutiveFailures = 0;
            } else {
                $consecutiveFailures++;
                Logger::warning("⚠️ OpenSearch degraded", [
                    'status' => $clusterStatus,
                    'response_time_ms' => round($responseTime, 2),
                    'consecutive_failures' => $consecutiveFailures
                ]);
            }

            $lastCheck = time();

        } catch (\Exception $e) {
            $isAvailable = false;
            $lastCheck = time();
            $consecutiveFailures++;

            Logger::warning("❌ OpenSearch check failed", [
                'error' => $e->getMessage(),
                'consecutive_failures' => $consecutiveFailures
            ]);
        }

        return $isAvailable;
    }

    private static function getClient(): \OpenSearch\Client
    {
        if (self::$client === null) {
            self::$client = ClientBuilder::create()
                ->setHosts(['localhost:9200'])
                ->setRetries(3)                    // Больше попыток
                ->setConnectionParams([
                    'timeout' => 20,               // HTTP timeout
                    'connect_timeout' => 5,        // Connection timeout
                    'client_timeout' => 25         // Общий timeout клиента
                ])
                ->setHandler(\OpenSearch\ClientBuilder::singleHandler()) // Одиночный обработчик
                ->build();
        }
        return self::$client;
    }

    private static function performOpenSearchWithTimeout(array $params, string $requestId): array
    {
        // Устанавливаем жесткие лимиты времени
        $originalTimeLimit = ini_get('max_execution_time');
        set_time_limit(30); // Максимум 30 секунд

        try {
            $body = [
                'timeout' => '15s', // Timeout на уровне OpenSearch
                'size' => $params['limit'],
                'from' => ($params['page'] - 1) * $params['limit'],
                'track_total_hits' => true,
                '_source' => [
                    'product_id', 'external_id', 'sku', 'name', 'description',
                    'brand_id', 'brand_name', 'series_id', 'series_name',
                    'unit', 'min_sale', 'weight', 'dimensions', 'images'
                ]
            ];

            // Ваша существующая логика построения запроса...
            if (!empty($params['q'])) {
                $query = mb_strtolower(trim($params['q']));
                $words = preg_split('/\s+/', $query, -1, PREG_SPLIT_NO_EMPTY);
                $isArticul = self::isArticul($query);

                $body['query'] = [
                    'function_score' => [
                        'query' => self::buildMainQuery($query, $words, $isArticul),
                        'functions' => self::buildScoringFunctions($query, $isArticul),
                        'score_mode' => 'sum',
                        'boost_mode' => 'multiply'
                    ]
                ];

                $body['highlight'] = [
                    'pre_tags' => ['<mark>'],
                    'post_tags' => ['</mark>'],
                    'fields' => [
                        'name' => ['number_of_fragments' => 0, 'fragment_size' => 300],
                        'external_id' => ['number_of_fragments' => 0],
                        'sku' => ['number_of_fragments' => 0],
                        'description' => ['fragment_size' => 150, 'number_of_fragments' => 1]
                    ]
                ];

                $body['rescore'] = [
                    'window_size' => 50,
                    'query' => [
                        'rescore_query' => [
                            'bool' => [
                                'should' => [
                                    ['match_phrase' => ['name' => ['query' => $query, 'boost' => 10]]],
                                    ['match' => ['name' => ['query' => $query, 'operator' => 'and', 'boost' => 5]]]
                                ]
                            ]
                        ],
                        'query_weight' => 0.7,
                        'rescore_query_weight' => 1.3
                    ]
                ];
            } else {
                $body['query'] = ['match_all' => new \stdClass()];
            }

            $body['sort'] = self::buildSort($params['sort'], !empty($params['q']));

            // Запрос с timeout'ами на всех уровнях
            $response = self::getClient()->search([
                'index' => 'products_current',
                'body' => $body,
                'client' => [
                    'timeout' => 20,          // HTTP timeout
                    'connect_timeout' => 5    // Connection timeout
                ]
            ]);

            return self::processResponse($response, $params);

        } catch (\Exception $e) {
            Logger::error("❌ [$requestId] OpenSearch timeout/error", [
                'error' => $e->getMessage(),
                'params' => $params
            ]);
            throw $e;
        } finally {
            // Восстанавливаем исходный лимит времени
            set_time_limit($originalTimeLimit);
        }
    }

    private static function checkSystemResources(): bool
    {
        // Проверка памяти
        $memoryUsage = memory_get_usage(true);
        $memoryLimit = self::parseMemoryLimit(ini_get('memory_limit'));

        if ($memoryUsage > $memoryLimit * 0.9) {
            Logger::warning("Memory usage critical", [
                'usage_mb' => round($memoryUsage / 1024 / 1024, 2),
                'limit_mb' => round($memoryLimit / 1024 / 1024, 2)
            ]);
            return false;
        }

        // Проверка нагрузки системы
        $load = sys_getloadavg();
        if ($load[0] > 10.0) {
            Logger::warning("System load high", ['load' => $load[0]]);
            return false;
        }

        return true;
    }

    private static function parseMemoryLimit(string $limit): int
    {
        $limit = trim($limit);
        $last = strtolower($limit[strlen($limit) - 1]);
        $limit = (int)$limit;

        switch ($last) {
            case 'g': $limit *= 1024 * 1024 * 1024; break;
            case 'm': $limit *= 1024 * 1024; break;
            case 'k': $limit *= 1024; break;
        }

        return $limit;
    }
}

# -------------------  HTTP (80) блок: только редирект на HTTPS  -------------------
server {
    listen 79.133.183.86:80 default_server;
    listen 80;
    server_name vdestor.ru www.vdestor.ru;
    root /var/www/www-root/data/site/vdestor.ru/public;

    # Перенаправление на HTTPS
    return 301 https://$host$request_uri;
}

# -------------------  HTTPS (443) основной блок  -------------------
server {
    listen 79.133.183.86:443 ssl http2 default_server;
    server_name vdestor.ru www.vdestor.ru;
    root /var/www/www-root/data/site/vdestor.ru/public;
    index index.php index.html;

    # SSL сертификаты
    ssl_certificate "/var/www/httpd-cert/www-root/vdestor.ru_le2.crtca";
    ssl_certificate_key "/var/www/httpd-cert/www-root/vdestor.ru_le2.key";
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_dhparam /etc/ssl/certs/dhparam4096.pem;
    ssl_ciphers EECDH:+AES256:-3DES:RSA+AES:!NULL:!RC4;

    # Безопасные заголовки (для всего сайта)
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options DENY always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy strict-origin-when-cross-origin always;
    add_header Content-Security-Policy "default-src 'self' https://vdestor.ru; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://vdestor.ru; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdnjs.cloudflare.com https://vdestor.ru; font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com data:; img-src 'self' data: https: blob:; connect-src 'self' https://vdestor.ru wss://vdestor.ru; object-src 'none'; base-uri 'self'; form-action 'self';" always;

    # Логи
    access_log /var/www/httpd-logs/vdestor.ru.access.log;
    error_log  /var/www/httpd-logs/vdestor.ru.error.log notice;

    # SSI, индексы, симлинки
    ssi on;
    disable_symlinks if_not_owner from=/var/www/www-root/data/site/vdestor.ru/public;
    charset off;

    # Включение Gzip
    gzip on;
    gzip_comp_level 5;
    gzip_disable "msie6";
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml;

    # Подключение инклудов (если используются)
    include /etc/nginx/vhosts-includes/*.conf;
    include /etc/nginx/vhosts-resources/vdestor.ru/*.conf;

    # Редирект www на не-www
    if ($host = www.vdestor.ru) {
        return 301 https://vdestor.ru$request_uri;
    }

    # ----------------- Защита доступа к скрытым и важным файлам -----------------
    location ~ /\.env {
        deny all;
        return 404;
    }

    location ~ /\.(git|svn|ht|DS_Store) {
        deny all;
    }

    location ~ ^/config/(generate_hash\.php|config_bd\.ini)$ {
        deny all;
        return 404;
    }

    # ----------------- Специальная обработка API -----------------
    location /api/ {
        # ВАЖНО: Направляем все API запросы в index.php
        try_files $uri $uri/ /index.php?$query_string;

        # Настройки для API
        limit_req zone=api burst=10 nodelay;

        # Обработка PHP для API (вложенный location)
        location ~ \.php$ {
            include /etc/nginx/vhosts-resources/vdestor.ru/dynamic/*.conf;
            fastcgi_index index.php;
            fastcgi_param PHP_ADMIN_VALUE "sendmail_path = /usr/sbin/sendmail -t -i -f vde76ru@yandex.ru";
            fastcgi_param HTTPS on;
            fastcgi_param HTTP_X_FORWARDED_PROTO $scheme;
            fastcgi_pass unix:/run/php/php8.1-fpm.sock;
            fastcgi_split_path_info ^((?U).+\.ph(?:p\d*|tml))(/?.+)$;
            try_files $uri =404;
            include fastcgi_params;
        }
    }

    # ----------------- Кеширование статических файлов -----------------
    location ~* ^.+\.(jpg|jpeg|gif|png|svg|js|css|mp3|ogg|mpe?g|avi|zip|gz|bz2?|rar|swf|webp|woff|woff2)$ {
        expires 7d;
        add_header Cache-Control "public, immutable";
    }

    # ----------------- Основной роутинг -----------------
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    # ----------------- Защита от прямого запуска PHP файлов -----------------
    location ~ [^/]\.ph(p\d*|tml)$ {
        try_files /does_not_exists @php;
    }

    # ----------------- PHP-обработчик (общий) -----------------
    location @php {
        include /etc/nginx/vhosts-resources/vdestor.ru/dynamic/*.conf;
        fastcgi_index index.php;
        fastcgi_param PHP_ADMIN_VALUE "sendmail_path = /usr/sbin/sendmail -t -i -f vde76ru@yandex.ru";
        fastcgi_param HTTPS on;
        fastcgi_param HTTP_X_FORWARDED_PROTO $scheme;
        fastcgi_pass unix:/run/php/php8.1-fpm.sock;
        fastcgi_split_path_info ^((?U).+\.ph(?:p\d*|tml))(/?.+)$;
        try_files $uri =404;
        include fastcgi_params;
    }
}